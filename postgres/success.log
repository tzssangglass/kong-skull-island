postgres  | ********************************************************************************
postgres  | WARNING: POSTGRES_HOST_AUTH_METHOD has been set to "trust". This will allow
postgres  |          anyone with access to the Postgres port to access your database without
postgres  |          a password, even if POSTGRES_PASSWORD is set. See PostgreSQL
postgres  |          documentation about "trust":
postgres  |          https://www.postgresql.org/docs/current/auth-trust.html
postgres  |          In Docker's default configuration, this is effectively any other
postgres  |          container on the same system.
postgres  | 
postgres  |          It is not recommended to use POSTGRES_HOST_AUTH_METHOD=trust. Replace
postgres  |          it with "-e POSTGRES_PASSWORD=password" instead to set a password in
postgres  |          "docker run".
postgres  | ********************************************************************************
postgres  | The files belonging to this database system will be owned by user "postgres".
postgres  | This user must also own the server process.
postgres  | 
postgres  | The database cluster will be initialized with locale "en_US.utf8".
postgres  | The default database encoding has accordingly been set to "UTF8".
postgres  | The default text search configuration will be set to "english".
postgres  | 
postgres  | Data page checksums are disabled.
postgres  | 
postgres  | fixing permissions on existing directory /var/lib/postgresql/data ... ok
postgres  | creating subdirectories ... ok
postgres  | selecting dynamic shared memory implementation ... posix
postgres  | selecting default max_connections ... 100
postgres  | selecting default shared_buffers ... 128MB
postgres  | selecting default time zone ... Etc/UTC
postgres  | creating configuration files ... ok
postgres  | running bootstrap script ... ok
postgres  | performing post-bootstrap initialization ... ok
postgres  | syncing data to disk ... ok
postgres  | 
postgres  | initdb: warning: enabling "trust" authentication for local connections
postgres  | initdb: hint: You can change this by editing pg_hba.conf or using the option -A, or --auth-local and --auth-host, the next time you run initdb.
postgres  | 
postgres  | Success. You can now start the database server using:
postgres  | 
postgres  |     pg_ctl -D /var/lib/postgresql/data -l logfile start
postgres  | 
postgres  | waiting for server to start....2023-09-19 07:30:23.482 UTC [49] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
postgres  | 2023-09-19 07:30:23.482 UTC [49] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
postgres  | 2023-09-19 07:30:23.484 UTC [52] LOG:  database system was shut down at 2023-09-19 07:30:23 UTC
postgres  | 2023-09-19 07:30:23.486 UTC [49] LOG:  database system is ready to accept connections
postgres  |  done
postgres  | server started
postgres  | CREATE DATABASE
postgres  | 
postgres  | 
postgres  | /usr/local/bin/docker-entrypoint.sh: running /docker-entrypoint-initdb.d/00-create-pg-db.sh
postgres  | Creating database kong
postgres  | GRANT
postgres  | Creating database kong_tests
postgres  | CREATE DATABASE
postgres  | GRANT
postgres  | 
postgres  | waiting for server to shut down....2023-09-19 07:30:23.669 UTC [49] LOG:  received fast shutdown request
postgres  | 2023-09-19 07:30:23.670 UTC [49] LOG:  aborting any active transactions
postgres  | 2023-09-19 07:30:23.671 UTC [49] LOG:  background worker "logical replication launcher" (PID 55) exited with exit code 1
postgres  | 2023-09-19 07:30:23.671 UTC [50] LOG:  shutting down
postgres  | 2023-09-19 07:30:23.671 UTC [50] LOG:  checkpoint starting: shutdown immediate
postgres  | 2023-09-19 07:30:23.695 UTC [50] LOG:  checkpoint complete: wrote 1830 buffers (11.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.024 s, sync=0.001 s, total=0.025 s; sync files=495, longest=0.001 s, average=0.000 s; distance=8446 kB, estimate=8446 kB
postgres  | 2023-09-19 07:30:23.698 UTC [49] LOG:  database system is shut down
postgres  |  done
postgres  | server stopped
postgres  | 
postgres  | PostgreSQL init process complete; ready for start up.
postgres  | 
postgres  | 2023-09-19 07:30:23.783 UTC [1] LOG:  starting PostgreSQL 15.3 (Debian 15.3-1.pgdg120+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 12.2.0-14) 12.2.0, 64-bit
postgres  | 2023-09-19 07:30:23.783 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
postgres  | 2023-09-19 07:30:23.783 UTC [1] LOG:  listening on IPv6 address "::", port 5432
postgres  | 2023-09-19 07:30:23.784 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
postgres  | 2023-09-19 07:30:23.786 UTC [73] LOG:  database system was shut down at 2023-09-19 07:30:23 UTC
postgres  | 2023-09-19 07:30:23.800 UTC [1] LOG:  database system is ready to accept connections
postgres  | 2023-09-19 07:30:33.395 UTC [91] LOG:  statement: SELECT CURRENT_SCHEMA AS schema
postgres  | 2023-09-19 07:30:33.395 UTC [91] LOG:  duration: 0.207 ms
postgres  | 2023-09-19 07:30:33.395 UTC [91] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:33.396 UTC [91] LOG:  duration: 0.186 ms
postgres  | 2023-09-19 07:30:33.396 UTC [91] LOG:  statement: SHOW server_version_num;
postgres  | 2023-09-19 07:30:33.396 UTC [91] LOG:  duration: 0.049 ms
postgres  | 2023-09-19 07:30:33.478 UTC [91] LOG:  statement: SELECT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	
postgres  | 2023-09-19 07:30:33.478 UTC [91] LOG:  duration: 0.470 ms
postgres  | 2023-09-19 07:30:33.544 UTC [91] LOG:  statement: SELECT CURRENT_SCHEMA AS schema
postgres  | 2023-09-19 07:30:33.544 UTC [91] LOG:  duration: 0.129 ms
postgres  | 2023-09-19 07:30:33.545 UTC [91] LOG:  statement: SHOW server_version_num;
postgres  | 2023-09-19 07:30:33.545 UTC [91] LOG:  duration: 0.051 ms
postgres  | 2023-09-19 07:30:33.569 UTC [91] LOG:  statement: SELECT table_name
postgres  | 	  FROM information_schema.tables
postgres  | 	 WHERE table_schema = CURRENT_SCHEMA;
postgres  | 	
postgres  | 2023-09-19 07:30:33.571 UTC [91] LOG:  duration: 1.535 ms
postgres  | 2023-09-19 07:30:33.573 UTC [92] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:33.573 UTC [92] LOG:  duration: 0.121 ms
postgres  | 2023-09-19 07:30:33.573 UTC [92] LOG:  statement: BEGIN;
postgres  | 	  DO $$
postgres  | 	  BEGIN
postgres  | 	    CREATE SCHEMA IF NOT EXISTS "public" AUTHORIZATION CURRENT_USER;
postgres  | 	    GRANT ALL ON SCHEMA "public" TO CURRENT_USER;
postgres  | 	  EXCEPTION WHEN insufficient_privilege THEN
postgres  | 	    -- Do nothing, perhaps the schema has been created already
postgres  | 	  END;
postgres  | 	  $$;
postgres  | 	  SET SCHEMA 'public';
postgres  | 	COMMIT;
postgres  | 2023-09-19 07:30:33.574 UTC [92] LOG:  duration: 0.854 ms
postgres  | 2023-09-19 07:30:33.574 UTC [92] LOG:  statement:     CREATE TABLE IF NOT EXISTS schema_meta (
postgres  | 	      key            TEXT,
postgres  | 	      subsystem      TEXT,
postgres  | 	      last_executed  TEXT,
postgres  | 	      executed       TEXT[],
postgres  | 	      pending        TEXT[],
postgres  | 	
postgres  | 	      PRIMARY KEY (key, subsystem)
postgres  | 	    );
postgres  | 2023-09-19 07:30:33.577 UTC [92] LOG:  duration: 2.681 ms
postgres  | 2023-09-19 07:30:33.577 UTC [92] LOG:  statement: BEGIN;
postgres  | 	  CREATE TABLE IF NOT EXISTS locks (
postgres  | 	    key    TEXT PRIMARY KEY,
postgres  | 	    owner  TEXT,
postgres  | 	    ttl    TIMESTAMP WITH TIME ZONE
postgres  | 	  );
postgres  | 	  CREATE INDEX IF NOT EXISTS locks_ttl_idx ON locks (ttl);
postgres  | 	COMMIT;
postgres  | 2023-09-19 07:30:33.579 UTC [92] LOG:  duration: 1.595 ms
postgres  | 2023-09-19 07:30:33.580 UTC [93] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:33.580 UTC [93] LOG:  duration: 0.112 ms
postgres  | 2023-09-19 07:30:33.581 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "cluster_events" (
postgres  | 	        "id"         UUID                       PRIMARY KEY,
postgres  | 	        "node_id"    UUID                       NOT NULL,
postgres  | 	        "at"         TIMESTAMP WITH TIME ZONE   NOT NULL,
postgres  | 	        "nbf"        TIMESTAMP WITH TIME ZONE,
postgres  | 	        "expire_at"  TIMESTAMP WITH TIME ZONE   NOT NULL,
postgres  | 	        "channel"    TEXT,
postgres  | 	        "data"       TEXT
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "cluster_events_at_idx" ON "cluster_events" ("at");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "cluster_events_channel_idx" ON "cluster_events" ("channel");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      CREATE OR REPLACE FUNCTION "delete_expired_cluster_events" () RETURNS TRIGGER
postgres  | 	      LANGUAGE plpgsql
postgres  | 	      AS $$
postgres  | 	        BEGIN
postgres  | 	          DELETE FROM "cluster_events"
postgres  | 	                WHERE "expire_at" <= CURRENT_TIMESTAMP AT TIME ZONE 'UTC';
postgres  | 	          RETURN NEW;
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS "delete_expired_cluster_events_trigger" ON "cluster_events";
postgres  | 	      CREATE TRIGGER "delete_expired_cluster_events_trigger"
postgres  | 	        AFTER INSERT ON "cluster_events"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE delete_expired_cluster_events();
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "services" (
postgres  | 	        "id"               UUID                       PRIMARY KEY,
postgres  | 	        "created_at"       TIMESTAMP WITH TIME ZONE,
postgres  | 	        "updated_at"       TIMESTAMP WITH TIME ZONE,
postgres  | 	        "name"             TEXT                       UNIQUE,
postgres  | 	        "retries"          BIGINT,
postgres  | 	        "protocol"         TEXT,
postgres  | 	        "host"             TEXT,
postgres  | 	        "port"             BIGINT,
postgres  | 	        "path"             TEXT,
postgres  | 	        "connect_timeout"  BIGINT,
postgres  | 	        "write_timeout"    BIGINT,
postgres  | 	        "read_timeout"     BIGINT
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "routes" (
postgres  | 	        "id"              UUID                       PRIMARY KEY,
postgres  | 	        "created_at"      TIMESTAMP WITH TIME ZONE,
postgres  | 	        "updated_at"      TIMESTAMP WITH TIME ZONE,
postgres  | 	        "name"            TEXT                       UNIQUE,
postgres  | 	        "service_id"      UUID                       REFERENCES "services" ("id"),
postgres  | 	        "protocols"       TEXT[],
postgres  | 	        "methods"         TEXT[],
postgres  | 	        "hosts"           TEXT[],
postgres  | 	        "paths"           TEXT[],
postgres  | 	        "snis"            TEXT[],
postgres  | 	        "sources"         JSONB[],
postgres  | 	        "destinations"    JSONB[],
postgres  | 	        "regex_priority"  BIGINT,
postgres  | 	        "strip_path"      BOOLEAN,
postgres  | 	        "preserve_host"   BOOLEAN
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "routes_service_id_idx" ON "routes" ("service_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "certificates" (
postgres  | 	        "id"          UUID                       PRIMARY KEY,
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE   DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "cert"        TEXT,
postgres  | 	        "key"         TEXT
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "snis" (
postgres  | 	        "id"              UUID                       PRIMARY KEY,
postgres  | 	        "created_at"      TIMESTAMP WITH TIME ZONE   DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "name"            TEXT                       NOT NULL UNIQUE,
postgres  | 	        "certificate_id"  UUID                       REFERENCES "certificates" ("id")
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "snis_certificate_id_idx" ON "snis" ("certificate_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "consumers" (
postgres  | 	        "id"          UUID                         PRIMARY KEY,
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "username"    TEXT                         UNIQUE,
postgres  | 	        "custom_id"   TEXT                         UNIQUE
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "consumers_username_idx" ON "consumers" (LOWER("username"));
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "plugins" (
postgres  | 	        "id"           UUID                         UNIQUE,
postgres  | 	        "created_at"   TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "name"         TEXT                         NOT NULL,
postgres  | 	        "consumer_id"  UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "service_id"   UUID                         REFERENCES "services"  ("id") ON DELETE CASCADE,
postgres  | 	        "route_id"     UUID                         REFERENCES "routes"    ("id") ON DELETE CASCADE,
postgres  | 	        "config"       JSONB                        NOT NULL,
postgres  | 	        "enabled"      BOOLEAN                      NOT NULL,
postgres  | 	        "cache_key"    TEXT                         UNIQUE,
postgres  | 	        "run_on"       TEXT,
postgres  | 	
postgres  | 	        PRIMARY KEY ("id")
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "plugins_name_idx" ON "plugins" ("name");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "plugins_consumer_id_idx" ON "plugins" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "plugins_service_id_idx" ON "plugins" ("service_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "plugins_route_id_idx" ON "plugins" ("route_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "plugins_run_on_idx" ON "plugins" ("run_on");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "upstreams" (
postgres  | 	        "id"                    UUID                         PRIMARY KEY,
postgres  | 	        "created_at"            TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'),
postgres  | 	        "name"                  TEXT                         UNIQUE,
postgres  | 	        "hash_on"               TEXT,
postgres  | 	        "hash_fallback"         TEXT,
postgres  | 	        "hash_on_header"        TEXT,
postgres  | 	        "hash_fallback_header"  TEXT,
postgres  | 	        "hash_on_cookie"        TEXT,
postgres  | 	        "hash_on_cookie_path"   TEXT,
postgres  | 	        "slots"                 INTEGER                      NOT NULL,
postgres  | 	        "healthchecks"          JSONB
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "targets" (
postgres  | 	        "id"           UUID                         PRIMARY KEY,
postgres  | 	        "created_at"   TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'),
postgres  | 	        "upstream_id"  UUID                         REFERENCES "upstreams" ("id") ON DELETE CASCADE,
postgres  | 	        "target"       TEXT                         NOT NULL,
postgres  | 	        "weight"       INTEGER                      NOT NULL
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "targets_target_idx" ON "targets" ("target");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "targets_upstream_id_idx" ON "targets" ("upstream_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "cluster_ca" (
postgres  | 	        "pk"    BOOLEAN  NOT NULL  PRIMARY KEY CHECK(pk=true),
postgres  | 	        "key"   TEXT     NOT NULL,
postgres  | 	        "cert"  TEXT     NOT NULL
postgres  | 	      );
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.601 UTC [93] LOG:  duration: 20.227 ms
postgres  | 2023-09-19 07:30:33.601 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '000_base', ARRAY['000_base'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base');
postgres  | 2023-09-19 07:30:33.601 UTC [93] LOG:  duration: 0.310 ms
postgres  | 2023-09-19 07:30:33.602 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        UPDATE consumers SET created_at = DATE_TRUNC('seconds', created_at);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        UPDATE plugins SET created_at = DATE_TRUNC('seconds', created_at);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        UPDATE upstreams SET created_at = DATE_TRUNC('seconds', created_at);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        UPDATE targets SET created_at = DATE_TRUNC('milliseconds', created_at);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DROP FUNCTION IF EXISTS "upsert_ttl" (TEXT, UUID, TEXT, TEXT, TIMESTAMP WITHOUT TIME ZONE);
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "plugins" ADD "protocols" TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "tags" (
postgres  | 	        entity_id         UUID    PRIMARY KEY,
postgres  | 	        entity_name       TEXT,
postgres  | 	        tags              TEXT[]
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS tags_entity_name_idx ON tags(entity_name);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS tags_tags_idx ON tags USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      CREATE OR REPLACE FUNCTION sync_tags() RETURNS trigger
postgres  | 	      LANGUAGE plpgsql
postgres  | 	      AS $$
postgres  | 	        BEGIN
postgres  | 	          IF (TG_OP = 'TRUNCATE') THEN
postgres  | 	            DELETE FROM tags WHERE entity_name = TG_TABLE_NAME;
postgres  | 	            RETURN NULL;
postgres  | 	          ELSIF (TG_OP = 'DELETE') THEN
postgres  | 	            DELETE FROM tags WHERE entity_id = OLD.id;
postgres  | 	            RETURN OLD;
postgres  | 	          ELSE
postgres  | 	
postgres  | 	          -- Triggered by INSERT/UPDATE
postgres  | 	          -- Do an upsert on the tags table
postgres  | 	          -- So we don't need to migrate pre 1.1 entities
postgres  | 	          INSERT INTO tags VALUES (NEW.id, TG_TABLE_NAME, NEW.tags)
postgres  | 	          ON CONFLICT (entity_id) DO UPDATE
postgres  | 	                  SET tags=EXCLUDED.tags;
postgres  | 	          END IF;
postgres  | 	          RETURN NEW;
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY services ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS services_tags_idx ON services USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS services_sync_tags_trigger ON services;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER services_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON services
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY routes ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS routes_tags_idx ON routes USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS routes_sync_tags_trigger ON routes;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER routes_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON routes
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY certificates ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS certificates_tags_idx ON certificates USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS certificates_sync_tags_trigger ON certificates;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER certificates_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON certificates
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY snis ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS snis_tags_idx ON snis USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS snis_sync_tags_trigger ON snis;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER snis_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON snis
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY consumers ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS consumers_tags_idx ON consumers USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS consumers_sync_tags_trigger ON consumers;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER consumers_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON consumers
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY plugins ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS plugins_tags_idx ON plugins USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS plugins_sync_tags_trigger ON plugins;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER plugins_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON plugins
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY upstreams ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS upstreams_tags_idx ON upstreams USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS upstreams_sync_tags_trigger ON upstreams;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER upstreams_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON upstreams
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY targets ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS targets_tags_idx ON targets USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS targets_sync_tags_trigger ON targets;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER targets_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON targets
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.606 UTC [93] LOG:  duration: 4.898 ms
postgres  | 2023-09-19 07:30:33.607 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '003_100_to_110', ARRAY['003_100_to_110'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_100_to_110');
postgres  | 2023-09-19 07:30:33.607 UTC [93] LOG:  duration: 0.189 ms
postgres  | 2023-09-19 07:30:33.607 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS cluster_events_expire_at_idx ON cluster_events(expire_at);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "routes" ADD "https_redirect_status_code" INTEGER;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.608 UTC [93] LOG:  duration: 0.707 ms
postgres  | 2023-09-19 07:30:33.608 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '004_110_to_120', ARRAY['004_110_to_120'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '004_110_to_120');
postgres  | 2023-09-19 07:30:33.608 UTC [93] LOG:  duration: 0.156 ms
postgres  | 2023-09-19 07:30:33.608 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "upstreams" ADD "algorithm" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "ca_certificates" (
postgres  | 	        "id"          UUID                       PRIMARY KEY,
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE   DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "cert"        TEXT NOT NULL              UNIQUE,
postgres  | 	        "tags"        TEXT[]
postgres  | 	      );
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS ca_certificates_sync_tags_trigger ON ca_certificates;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER ca_certificates_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON ca_certificates
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "routes" ADD "headers" JSONB;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "services" ADD "client_certificate_id" UUID REFERENCES "certificates" ("id");
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "services_fkey_client_certificate" ON "services" ("client_certificate_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.611 UTC [93] LOG:  duration: 2.442 ms
postgres  | 2023-09-19 07:30:33.611 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'core', ARRAY['005_120_to_130'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '005_120_to_130');
postgres  | 2023-09-19 07:30:33.611 UTC [93] LOG:  duration: 0.187 ms
postgres  | 2023-09-19 07:30:33.611 UTC [93] LOG:  statement: SELECT id, algorithm, hash_on FROM upstreams
postgres  | 2023-09-19 07:30:33.611 UTC [93] LOG:  duration: 0.097 ms
postgres  | 2023-09-19 07:30:33.612 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '005_120_to_130', ARRAY['005_120_to_130'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '005_120_to_130'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '005_120_to_130');
postgres  | 2023-09-19 07:30:33.612 UTC [93] LOG:  duration: 0.185 ms
postgres  | 2023-09-19 07:30:33.612 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "upstreams" ADD "host_header" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS "delete_expired_cluster_events_trigger" ON "cluster_events";
postgres  | 	      DROP FUNCTION IF EXISTS "delete_expired_cluster_events" ();
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.613 UTC [93] LOG:  duration: 0.613 ms
postgres  | 2023-09-19 07:30:33.613 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '006_130_to_140', ARRAY['006_130_to_140'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '006_130_to_140');
postgres  | 2023-09-19 07:30:33.613 UTC [93] LOG:  duration: 0.169 ms
postgres  | 2023-09-19 07:30:33.613 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- If migrating from 1.x, the "path_handling" column does not exist yet.
postgres  | 	      -- Create it with a default of 'v1' to fill existing rows.
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "routes" ADD "path_handling" TEXT DEFAULT 'v1';
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.614 UTC [93] LOG:  duration: 0.255 ms
postgres  | 2023-09-19 07:30:33.614 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '007_140_to_150', ARRAY['007_140_to_150'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '007_140_to_150');
postgres  | 2023-09-19 07:30:33.614 UTC [93] LOG:  duration: 0.143 ms
postgres  | 2023-09-19 07:30:33.614 UTC [93] LOG:  statement: BEGIN;
postgres  | 	ALTER TABLE IF EXISTS ONLY "routes" ALTER COLUMN "path_handling" SET DEFAULT 'v0';
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.615 UTC [93] LOG:  duration: 0.226 ms
postgres  | 2023-09-19 07:30:33.615 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'core', ARRAY['008_150_to_200'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '008_150_to_200');
postgres  | 2023-09-19 07:30:33.615 UTC [93] LOG:  duration: 0.143 ms
postgres  | 2023-09-19 07:30:33.615 UTC [93] LOG:  statement:         DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" DROP COLUMN "run_on";
postgres  | 	        EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          DROP TABLE IF EXISTS "cluster_ca";
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.616 UTC [93] LOG:  duration: 0.636 ms
postgres  | 2023-09-19 07:30:33.616 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '008_150_to_200', ARRAY['008_150_to_200'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '008_150_to_200'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '008_150_to_200');
postgres  | 2023-09-19 07:30:33.616 UTC [93] LOG:  duration: 0.162 ms
postgres  | 2023-09-19 07:30:33.616 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- ca_certificates table
postgres  | 	        ALTER TABLE IF EXISTS ONLY ca_certificates DROP CONSTRAINT IF EXISTS ca_certificates_cert_key;
postgres  | 	
postgres  | 	        DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY ca_certificates ADD COLUMN "cert_digest" TEXT UNIQUE;
postgres  | 	          EXCEPTION WHEN duplicate_column THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	        DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY services ADD COLUMN "tls_verify" BOOLEAN;
postgres  | 	          EXCEPTION WHEN duplicate_column THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	        -- add certificates reference to upstreams table
postgres  | 	        DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "upstreams" ADD "client_certificate_id" UUID REFERENCES "certificates" ("id");
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	        DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY services ADD COLUMN "tls_verify_depth" SMALLINT;
postgres  | 	          EXCEPTION WHEN duplicate_column THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	        DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY services ADD COLUMN "ca_certificates" UUID[];
postgres  | 	          EXCEPTION WHEN duplicate_column THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	        DO $$
postgres  | 	          BEGIN
postgres  | 	            CREATE INDEX IF NOT EXISTS "upstreams_fkey_client_certificate" ON "upstreams" ("client_certificate_id");
postgres  | 	          EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	    
postgres  | 	        CREATE TABLE IF NOT EXISTS "workspaces" (
postgres  | 	          "id"         UUID                       PRIMARY KEY,
postgres  | 	          "name"       TEXT                       UNIQUE,
postgres  | 	          "comment"    TEXT,
postgres  | 	          "created_at" TIMESTAMP WITH TIME ZONE   DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	          "meta"       JSONB,
postgres  | 	          "config"     JSONB
postgres  | 	        );
postgres  | 	
postgres  | 	        -- Create default workspace
postgres  | 	        INSERT INTO workspaces(id, name)
postgres  | 	        VALUES ('76318f38-0348-44c4-a243-14e7480a11d5', 'default') ON CONFLICT DO NOTHING;
postgres  | 	
postgres  | 	              -- Add ws_id to upstreams, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "upstreams" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "upstreams" ADD CONSTRAINT "upstreams_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'upstreams.name' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "upstreams" DROP CONSTRAINT IF EXISTS "upstreams_name_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, name) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "upstreams" ADD CONSTRAINT "upstreams_ws_id_name_unique" UNIQUE ("ws_id", "name");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to targets, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "targets" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "targets" ADD CONSTRAINT "targets_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "targets" DROP CONSTRAINT IF EXISTS "targets_upstream_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "targets"
postgres  | 	                        ADD CONSTRAINT "targets_upstream_id_fkey"
postgres  | 	                           FOREIGN KEY ("upstream_id", "ws_id")
postgres  | 	                            REFERENCES upstreams("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to consumers, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "consumers" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumers" ADD CONSTRAINT "consumers_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'consumers.username' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumers" DROP CONSTRAINT IF EXISTS "consumers_username_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, username) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "consumers" ADD CONSTRAINT "consumers_ws_id_username_unique" UNIQUE ("ws_id", "username");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'consumers.custom_id' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumers" DROP CONSTRAINT IF EXISTS "consumers_custom_id_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, custom_id) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "consumers" ADD CONSTRAINT "consumers_ws_id_custom_id_unique" UNIQUE ("ws_id", "custom_id");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to certificates, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "certificates" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "certificates" ADD CONSTRAINT "certificates_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to snis, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "snis" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "snis" ADD CONSTRAINT "snis_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "snis" DROP CONSTRAINT IF EXISTS "snis_certificate_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "snis"
postgres  | 	                        ADD CONSTRAINT "snis_certificate_id_fkey"
postgres  | 	                           FOREIGN KEY ("certificate_id", "ws_id")
postgres  | 	                            REFERENCES certificates("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to services, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "services" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "services" ADD CONSTRAINT "services_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "services" DROP CONSTRAINT IF EXISTS "services_client_certificate_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "services"
postgres  | 	                        ADD CONSTRAINT "services_client_certificate_id_fkey"
postgres  | 	                           FOREIGN KEY ("client_certificate_id", "ws_id")
postgres  | 	                            REFERENCES certificates("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'services.name' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "services" DROP CONSTRAINT IF EXISTS "services_name_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, name) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "services" ADD CONSTRAINT "services_ws_id_name_unique" UNIQUE ("ws_id", "name");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to routes, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "routes" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "routes" ADD CONSTRAINT "routes_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "routes" DROP CONSTRAINT IF EXISTS "routes_service_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "routes"
postgres  | 	                        ADD CONSTRAINT "routes_service_id_fkey"
postgres  | 	                           FOREIGN KEY ("service_id", "ws_id")
postgres  | 	                            REFERENCES services("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'routes.name' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "routes" DROP CONSTRAINT IF EXISTS "routes_name_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, name) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "routes" ADD CONSTRAINT "routes_ws_id_name_unique" UNIQUE ("ws_id", "name");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to plugins, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "plugins" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" ADD CONSTRAINT "plugins_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" DROP CONSTRAINT IF EXISTS "plugins_route_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "plugins"
postgres  | 	                        ADD CONSTRAINT "plugins_route_id_fkey"
postgres  | 	                           FOREIGN KEY ("route_id", "ws_id")
postgres  | 	                            REFERENCES routes("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" DROP CONSTRAINT IF EXISTS "plugins_service_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "plugins"
postgres  | 	                        ADD CONSTRAINT "plugins_service_id_fkey"
postgres  | 	                           FOREIGN KEY ("service_id", "ws_id")
postgres  | 	                            REFERENCES services("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" DROP CONSTRAINT IF EXISTS "plugins_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "plugins"
postgres  | 	                        ADD CONSTRAINT "plugins_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.632 UTC [93] LOG:  duration: 15.500 ms
postgres  | 2023-09-19 07:30:33.632 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'core', ARRAY['009_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '009_200_to_210');
postgres  | 2023-09-19 07:30:33.632 UTC [93] LOG:  duration: 0.188 ms
postgres  | 2023-09-19 07:30:33.632 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "upstreams" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.632 UTC [93] LOG:  duration: 0.191 ms
postgres  | 2023-09-19 07:30:33.633 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "targets" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.633 UTC [93] LOG:  duration: 0.185 ms
postgres  | 2023-09-19 07:30:33.633 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "consumers" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.633 UTC [93] LOG:  duration: 0.176 ms
postgres  | 2023-09-19 07:30:33.633 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "certificates" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.633 UTC [93] LOG:  duration: 0.176 ms
postgres  | 2023-09-19 07:30:33.633 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "snis" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.634 UTC [93] LOG:  duration: 0.167 ms
postgres  | 2023-09-19 07:30:33.634 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "services" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.634 UTC [93] LOG:  duration: 0.169 ms
postgres  | 2023-09-19 07:30:33.634 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "routes" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.634 UTC [93] LOG:  duration: 0.164 ms
postgres  | 2023-09-19 07:30:33.634 UTC [93] LOG:  statement:         UPDATE "plugins"
postgres  | 	        SET cache_key = CONCAT(cache_key, ':',
postgres  | 	                               (SELECT id FROM workspaces WHERE name = 'default'))
postgres  | 	        WHERE cache_key LIKE '%:';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.635 UTC [93] LOG:  duration: 0.211 ms
postgres  | 2023-09-19 07:30:33.635 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "plugins" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.635 UTC [93] LOG:  duration: 0.158 ms
postgres  | 2023-09-19 07:30:33.635 UTC [93] LOG:  statement: SELECT id, cert, cert_digest FROM ca_certificates
postgres  | 2023-09-19 07:30:33.635 UTC [93] LOG:  duration: 0.101 ms
postgres  | 2023-09-19 07:30:33.635 UTC [93] LOG:  statement:     DO $$
postgres  | 	    BEGIN
postgres  | 	      ALTER TABLE IF EXISTS ONLY "ca_certificates" ALTER COLUMN "cert_digest" SET NOT NULL;
postgres  | 	    EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	      -- Do nothing, accept existing state
postgres  | 	    END;
postgres  | 	    $$;
postgres  | 	  
postgres  | 2023-09-19 07:30:33.635 UTC [93] LOG:  duration: 0.154 ms
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '009_200_to_210', ARRAY['009_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '009_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '009_200_to_210');
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  statement: BEGIN;
postgres  | 	SELECT 1;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  duration: 0.044 ms
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '010_210_to_211', ARRAY['010_210_to_211'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '010_210_to_211');
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- Unique constraint on "name" already adds btree index
postgres  | 	      DROP INDEX IF EXISTS "workspaces_name_idx";
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.636 UTC [93] LOG:  duration: 0.067 ms
postgres  | 2023-09-19 07:30:33.637 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '011_212_to_213', ARRAY['011_212_to_213'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '011_212_to_213');
postgres  | 2023-09-19 07:30:33.637 UTC [93] LOG:  duration: 0.147 ms
postgres  | 2023-09-19 07:30:33.637 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "clustering_data_planes" (
postgres  | 	        id             UUID PRIMARY KEY,
postgres  | 	        hostname       TEXT NOT NULL,
postgres  | 	        ip             TEXT NOT NULL,
postgres  | 	        last_seen      TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        config_hash    TEXT NOT NULL,
postgres  | 	        ttl            TIMESTAMP WITH TIME ZONE
postgres  | 	      );
postgres  | 	      CREATE INDEX IF NOT EXISTS clustering_data_planes_ttl_idx ON clustering_data_planes (ttl);
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "routes" ADD "request_buffering" BOOLEAN;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "routes" ADD "response_buffering" BOOLEAN;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.639 UTC [93] LOG:  duration: 1.679 ms
postgres  | 2023-09-19 07:30:33.639 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'core', ARRAY['012_213_to_220'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '012_213_to_220');
postgres  | 2023-09-19 07:30:33.639 UTC [93] LOG:  duration: 0.144 ms
postgres  | 2023-09-19 07:30:33.639 UTC [93] LOG:  statement:         DELETE FROM targets t1
postgres  | 	              USING targets t2
postgres  | 	              WHERE t1.created_at < t2.created_at
postgres  | 	                AND t1.upstream_id = t2.upstream_id
postgres  | 	                AND t1.target = t2.target;
postgres  | 	        
postgres  | 2023-09-19 07:30:33.640 UTC [93] LOG:  duration: 0.205 ms
postgres  | 2023-09-19 07:30:33.640 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '012_213_to_220', ARRAY['012_213_to_220'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '012_213_to_220'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '012_213_to_220');
postgres  | 2023-09-19 07:30:33.640 UTC [93] LOG:  duration: 0.155 ms
postgres  | 2023-09-19 07:30:33.640 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "parameters" (
postgres  | 	        key            TEXT PRIMARY KEY,
postgres  | 	        value          TEXT NOT NULL,
postgres  | 	        created_at     TIMESTAMP WITH TIME ZONE
postgres  | 	      );
postgres  | 	
postgres  | 	      INSERT INTO parameters (key, value) VALUES('cluster_id', '1f94d00f-8cb6-4b59-aa29-320e25269e8c')
postgres  | 	      ON CONFLICT DO NOTHING;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "certificates" ADD "cert_alt" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "certificates" ADD "key_alt" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "clustering_data_planes" ADD "version" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "clustering_data_planes" ADD "sync_status" TEXT NOT NULL DEFAULT 'unknown';
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.642 UTC [93] LOG:  duration: 1.660 ms
postgres  | 2023-09-19 07:30:33.642 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '013_220_to_230', ARRAY['013_220_to_230'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '013_220_to_230');
postgres  | 2023-09-19 07:30:33.642 UTC [93] LOG:  duration: 0.151 ms
postgres  | 2023-09-19 07:30:33.642 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "consumers" ADD "username_lower" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      UPDATE consumers SET username_lower=LOWER(username);
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.642 UTC [93] LOG:  duration: 0.246 ms
postgres  | 2023-09-19 07:30:33.643 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '014_230_to_260', ARRAY['014_230_to_260'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '014_230_to_260');
postgres  | 2023-09-19 07:30:33.643 UTC [93] LOG:  duration: 0.143 ms
postgres  | 2023-09-19 07:30:33.643 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "services" ADD "enabled" BOOLEAN DEFAULT true;
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.643 UTC [93] LOG:  duration: 0.209 ms
postgres  | 2023-09-19 07:30:33.643 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '015_260_to_270', ARRAY['015_260_to_270'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '015_260_to_270');
postgres  | 2023-09-19 07:30:33.643 UTC [93] LOG:  duration: 0.138 ms
postgres  | 2023-09-19 07:30:33.644 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        -- we don't want to recreate vaults_beta again, if this migration is ran twice
postgres  | 	        IF (SELECT to_regclass('vaults_tags_idx')) IS NULL THEN
postgres  | 	          CREATE TABLE IF NOT EXISTS "vaults_beta" (
postgres  | 	            "id"           UUID                      PRIMARY KEY,
postgres  | 	            "ws_id"        UUID                      REFERENCES "workspaces" ("id"),
postgres  | 	            "prefix"       TEXT                      UNIQUE,
postgres  | 	            "name"         TEXT                      NOT NULL,
postgres  | 	            "description"  TEXT,
postgres  | 	            "config"       JSONB                     NOT NULL,
postgres  | 	            "created_at"   TIMESTAMP WITH TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	            "updated_at"   TIMESTAMP WITH TIME ZONE,
postgres  | 	            "tags"         TEXT[],
postgres  | 	            UNIQUE ("id", "ws_id"),
postgres  | 	            UNIQUE ("prefix", "ws_id")
postgres  | 	          );
postgres  | 	
postgres  | 	          DROP TRIGGER IF EXISTS "vaults_beta_sync_tags_trigger" ON "vaults_beta";
postgres  | 	
postgres  | 	          BEGIN
postgres  | 	            CREATE INDEX IF NOT EXISTS "vaults_beta_tags_idx" ON "vaults_beta" USING GIN ("tags");
postgres  | 	          EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	
postgres  | 	          BEGIN
postgres  | 	            CREATE TRIGGER "vaults_beta_sync_tags_trigger"
postgres  | 	            AFTER INSERT OR UPDATE OF "tags" OR DELETE ON "vaults_beta"
postgres  | 	            FOR EACH ROW
postgres  | 	            EXECUTE PROCEDURE sync_tags();
postgres  | 	          EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	        END IF;
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.646 UTC [93] LOG:  duration: 2.699 ms
postgres  | 2023-09-19 07:30:33.647 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '016_270_to_280', ARRAY['016_270_to_280'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '016_270_to_280');
postgres  | 2023-09-19 07:30:33.647 UTC [93] LOG:  duration: 0.232 ms
postgres  | 2023-09-19 07:30:33.647 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	        BEGIN
postgres  | 	          IF (SELECT to_regclass('vaults_beta')) IS NOT NULL AND (SELECT to_regclass('sm_vaults')) IS NULL THEN
postgres  | 	            CREATE TABLE sm_vaults ( LIKE vaults_beta INCLUDING ALL );
postgres  | 	
postgres  | 	            CREATE TRIGGER "sm_vaults_sync_tags_trigger"
postgres  | 	            AFTER INSERT OR UPDATE OF tags OR DELETE ON sm_vaults
postgres  | 	            FOR EACH ROW
postgres  | 	            EXECUTE PROCEDURE sync_tags();
postgres  | 	
postgres  | 	            ALTER TABLE sm_vaults ADD CONSTRAINT sm_vaults_ws_id_fkey FOREIGN KEY(ws_id) REFERENCES workspaces(id);
postgres  | 	
postgres  | 	            INSERT INTO sm_vaults SELECT * FROM vaults_beta;
postgres  | 	          END IF;
postgres  | 	
postgres  | 	          IF (SELECT to_regclass('vaults')) IS NOT NULL AND (SELECT to_regclass('vault_auth_vaults')) IS NULL THEN
postgres  | 	            CREATE TABLE vault_auth_vaults ( LIKE vaults INCLUDING ALL );
postgres  | 	
postgres  | 	            INSERT INTO vault_auth_vaults SELECT * FROM vaults;
postgres  | 	          END IF;
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "targets" ADD COLUMN "cache_key" TEXT UNIQUE;
postgres  | 	        EXCEPTION WHEN duplicate_column THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      -- add new hash_on_query_arg field to upstreams
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "upstreams" ADD "hash_on_query_arg" TEXT;
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      -- add new hash_fallback_query_arg field to upstreams
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "upstreams" ADD "hash_fallback_query_arg" TEXT;
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      -- add new hash_on_uri_capture field to upstreams
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "upstreams" ADD "hash_on_uri_capture" TEXT;
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      -- add new hash_fallback_uri_capture field to upstreams
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "upstreams" ADD "hash_fallback_uri_capture" TEXT;
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "routes" ADD COLUMN "expression" TEXT;
postgres  | 	        EXCEPTION WHEN duplicate_column THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "routes" ADD COLUMN "priority" BIGINT;
postgres  | 	        EXCEPTION WHEN duplicate_column THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.651 UTC [93] LOG:  duration: 3.763 ms
postgres  | 2023-09-19 07:30:33.651 UTC [93] LOG:  statement: SELECT id, paths FROM routes WHERE paths IS NOT NULL
postgres  | 2023-09-19 07:30:33.651 UTC [93] LOG:  duration: 0.122 ms
postgres  | 2023-09-19 07:30:33.651 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'core', ARRAY['016_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '016_280_to_300');
postgres  | 2023-09-19 07:30:33.651 UTC [93] LOG:  duration: 0.139 ms
postgres  | 2023-09-19 07:30:33.651 UTC [93] LOG:  statement:         DROP TABLE IF EXISTS vaults_beta;
postgres  | 	        DROP TABLE IF EXISTS vaults;
postgres  | 	        
postgres  | 2023-09-19 07:30:33.652 UTC [93] LOG:  duration: 0.638 ms
postgres  | 2023-09-19 07:30:33.652 UTC [93] LOG:  statement:     DELETE FROM targets t1
postgres  | 	          USING targets t2
postgres  | 	          WHERE t1.created_at < t2.created_at
postgres  | 	            AND t1.upstream_id = t2.upstream_id
postgres  | 	            AND t1.target = t2.target;
postgres  | 	    UPDATE targets SET cache_key = CONCAT('targets:', upstream_id, ':', target, '::::', ws_id);
postgres  | 	    
postgres  | 2023-09-19 07:30:33.652 UTC [93] LOG:  duration: 0.199 ms
postgres  | 2023-09-19 07:30:33.653 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '016_280_to_300', ARRAY['016_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '016_280_to_300'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '016_280_to_300');
postgres  | 2023-09-19 07:30:33.653 UTC [93] LOG:  duration: 0.154 ms
postgres  | 2023-09-19 07:30:33.653 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	            BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "upstreams" ADD "use_srv_name"  BOOLEAN DEFAULT false;
postgres  | 	            EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	            END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	        CREATE TABLE IF NOT EXISTS "key_sets" (
postgres  | 	          "id"           UUID                       PRIMARY KEY,
postgres  | 	          "name"         TEXT                       UNIQUE,
postgres  | 	          "tags"         TEXT[],
postgres  | 	          "ws_id"        UUID                       REFERENCES "workspaces" ("id"),
postgres  | 	          "created_at"   TIMESTAMP WITH TIME ZONE,
postgres  | 	          "updated_at"   TIMESTAMP WITH TIME ZONE
postgres  | 	        );
postgres  | 	
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          CREATE INDEX IF NOT EXISTS "key_sets_tags_idx" ON "key_sets" USING GIN ("tags");
postgres  | 	        EXCEPTION WHEN UNDEFINED_COLUMN then
postgres  | 	          -- do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	        DROP TRIGGER IF EXISTS "key_sets_sync_tags_trigger" ON "key_sets";
postgres  | 	
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          CREATE TRIGGER "key_sets_sync_tags_trigger"
postgres  | 	          AFTER INSERT OR UPDATE OF "tags"
postgres  | 	                      OR DELETE ON "key_sets"
postgres  | 	          FOR EACH ROW
postgres  | 	          EXECUTE PROCEDURE "sync_tags" ();
postgres  | 	        EXCEPTION WHEN undefined_column OR undefined_table THEN
postgres  | 	          -- do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	        CREATE TABLE IF NOT EXISTS "keys" (
postgres  | 	          "id"           UUID                       PRIMARY KEY,
postgres  | 	          "set_id"       UUID                       REFERENCES "key_sets" ("id") on delete cascade,
postgres  | 	          "name"         TEXT                       UNIQUE,
postgres  | 	          "cache_key"    TEXT                       UNIQUE,
postgres  | 	          "ws_id"        UUID                       REFERENCES "workspaces" ("id"),
postgres  | 	          "kid"          TEXT,
postgres  | 	          "jwk"          TEXT,
postgres  | 	          "pem"          JSONB,
postgres  | 	          "tags"         TEXT[],
postgres  | 	          "created_at"   TIMESTAMP WITH TIME ZONE,
postgres  | 	          "updated_at"   TIMESTAMP WITH TIME ZONE,
postgres  | 	          UNIQUE ("kid", "set_id")
postgres  | 	        );
postgres  | 	
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          CREATE INDEX IF NOT EXISTS "keys_fkey_key_sets" ON "keys" ("set_id");
postgres  | 	        EXCEPTION WHEN undefined_column THEN
postgres  | 	          -- do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          CREATE INDEX IF NOT EXISTS "keys_tags_idx" ON "keys" USING GIN ("tags");
postgres  | 	        EXCEPTION WHEN undefined_column THEN
postgres  | 	          -- do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	        DROP TRIGGER IF EXISTS "keys_sync_tags_trigger" ON "keys";
postgres  | 	
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          CREATE TRIGGER "keys_sync_tags_trigger"
postgres  | 	          AFTER INSERT OR UPDATE OF "tags"
postgres  | 	                      OR DELETE ON "keys"
postgres  | 	          FOR EACH ROW
postgres  | 	          EXECUTE PROCEDURE "sync_tags" ();
postgres  | 	        EXCEPTION WHEN undefined_column or UNDEFINED_TABLE then
postgres  | 	          -- do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.658 UTC [93] LOG:  duration: 4.756 ms
postgres  | 2023-09-19 07:30:33.658 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '017_300_to_310', ARRAY['017_300_to_310'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '017_300_to_310');
postgres  | 2023-09-19 07:30:33.658 UTC [93] LOG:  duration: 0.247 ms
postgres  | 2023-09-19 07:30:33.658 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	            BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "plugins" ADD "instance_name" TEXT;
postgres  | 	            ALTER TABLE IF EXISTS ONLY "plugins" ADD CONSTRAINT "plugins_ws_id_instance_name_unique" UNIQUE ("ws_id", "instance_name");
postgres  | 	            EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	            END;
postgres  | 	        $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.659 UTC [93] LOG:  duration: 0.613 ms
postgres  | 2023-09-19 07:30:33.659 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '018_310_to_320', ARRAY['018_310_to_320'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '018_310_to_320');
postgres  | 2023-09-19 07:30:33.659 UTC [93] LOG:  duration: 0.147 ms
postgres  | 2023-09-19 07:30:33.659 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "ca_certificates" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "certificates" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumers" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "snis" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "targets" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "upstreams" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "workspaces" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "clustering_data_planes" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      CREATE OR REPLACE FUNCTION batch_delete_expired_rows() RETURNS trigger
postgres  | 	      LANGUAGE plpgsql
postgres  | 	      AS $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE FORMAT('WITH rows AS (SELECT ctid FROM %s WHERE %s < CURRENT_TIMESTAMP AT TIME ZONE ''UTC'' ORDER BY %s LIMIT 2 FOR UPDATE SKIP LOCKED) DELETE FROM %s WHERE ctid IN (TABLE rows)', TG_TABLE_NAME, TG_ARGV[0], TG_ARGV[0], TG_TABLE_NAME);
postgres  | 	          RETURN NULL;
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS "cluster_events_ttl_trigger" ON "cluster_events";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "cluster_events_ttl_trigger"
postgres  | 	        AFTER INSERT ON "cluster_events"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("expire_at");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS "clustering_data_planes_ttl_trigger" ON "clustering_data_planes";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "clustering_data_planes_ttl_trigger"
postgres  | 	        AFTER INSERT ON "clustering_data_planes"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.661 UTC [93] LOG:  duration: 1.365 ms
postgres  | 2023-09-19 07:30:33.661 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '019_320_to_330', ARRAY['019_320_to_330'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '019_320_to_330');
postgres  | 2023-09-19 07:30:33.661 UTC [93] LOG:  duration: 0.162 ms
postgres  | 2023-09-19 07:30:33.661 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DROP TABLE IF EXISTS "ttls";
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "filter_chains" (
postgres  | 	        "id"          UUID                       PRIMARY KEY,
postgres  | 	        "name"        TEXT                       UNIQUE,
postgres  | 	        "enabled"     BOOLEAN                    DEFAULT TRUE,
postgres  | 	        "route_id"    UUID                       REFERENCES "routes"     ("id") ON DELETE CASCADE,
postgres  | 	        "service_id"  UUID                       REFERENCES "services"   ("id") ON DELETE CASCADE,
postgres  | 	        "ws_id"       UUID                       REFERENCES "workspaces" ("id") ON DELETE CASCADE,
postgres  | 	        "cache_key"   TEXT                       UNIQUE,
postgres  | 	        "filters"     JSONB[],
postgres  | 	        "tags"        TEXT[],
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE,
postgres  | 	        "updated_at"  TIMESTAMP WITH TIME ZONE
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE UNIQUE INDEX IF NOT EXISTS "filter_chains_name_idx"
postgres  | 	          ON "filter_chains" ("name");
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE UNIQUE INDEX IF NOT EXISTS "filter_chains_cache_key_idx"
postgres  | 	          ON "filter_chains" ("cache_key");
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "filter_chains_tags_idx" ON "filter_chains" USING GIN ("tags");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN then
postgres  | 	        -- do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS "filter_chains_sync_tags_trigger" ON "filter_chains";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "filter_chains_sync_tags_trigger"
postgres  | 	        AFTER INSERT OR UPDATE OF "tags"
postgres  | 	                    OR DELETE ON "filter_chains"
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE "sync_tags" ();
postgres  | 	      EXCEPTION WHEN undefined_column OR undefined_table THEN
postgres  | 	        -- do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.665 UTC [93] LOG:  duration: 3.414 ms
postgres  | 2023-09-19 07:30:33.665 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'core', '020_330_to_340', ARRAY['020_330_to_340'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '020_330_to_340');
postgres  | 2023-09-19 07:30:33.665 UTC [93] LOG:  duration: 0.167 ms
postgres  | 2023-09-19 07:30:33.665 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "acls" (
postgres  | 	        "id"           UUID                         PRIMARY KEY,
postgres  | 	        "created_at"   TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "consumer_id"  UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "group"        TEXT,
postgres  | 	        "cache_key"    TEXT                         UNIQUE
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "acls_consumer_id_idx" ON "acls" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "acls_group_idx" ON "acls" ("group");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.668 UTC [93] LOG:  duration: 2.511 ms
postgres  | 2023-09-19 07:30:33.668 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'acl', '000_base_acl', ARRAY['000_base_acl'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_acl');
postgres  | 2023-09-19 07:30:33.668 UTC [93] LOG:  duration: 0.152 ms
postgres  | 2023-09-19 07:30:33.668 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY acls ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS acls_tags_idex_tags_idx ON acls USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS acls_sync_tags_trigger ON acls;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER acls_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON acls
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.669 UTC [93] LOG:  duration: 0.432 ms
postgres  | 2023-09-19 07:30:33.669 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'acl', '002_130_to_140', ARRAY['002_130_to_140'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_130_to_140');
postgres  | 2023-09-19 07:30:33.669 UTC [93] LOG:  duration: 0.142 ms
postgres  | 2023-09-19 07:30:33.669 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- Add ws_id to acls, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "acls" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "acls" ADD CONSTRAINT "acls_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "acls" DROP CONSTRAINT IF EXISTS "acls_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "acls"
postgres  | 	                        ADD CONSTRAINT "acls_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.670 UTC [93] LOG:  duration: 1.524 ms
postgres  | 2023-09-19 07:30:33.671 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'acl', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '003_200_to_210');
postgres  | 2023-09-19 07:30:33.671 UTC [93] LOG:  duration: 0.150 ms
postgres  | 2023-09-19 07:30:33.671 UTC [93] LOG:  statement:         UPDATE "acls"
postgres  | 	        SET cache_key = CONCAT(cache_key, ':',
postgres  | 	                               (SELECT id FROM workspaces WHERE name = 'default'))
postgres  | 	        WHERE cache_key LIKE '%:';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.671 UTC [93] LOG:  duration: 0.142 ms
postgres  | 2023-09-19 07:30:33.671 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "acls" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  duration: 0.161 ms
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  duration: 0.109 ms
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'acl', '003_200_to_210', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '003_200_to_210');
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  duration: 0.148 ms
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'acl', ARRAY['004_212_to_213'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '004_212_to_213');
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  duration: 0.139 ms
postgres  | 2023-09-19 07:30:33.672 UTC [93] LOG:  statement:         UPDATE "acls"
postgres  | 	        SET cache_key = CONCAT(cache_key, ':',
postgres  | 	                               (SELECT id FROM workspaces WHERE name = 'default'))
postgres  | 	        WHERE cache_key LIKE '%:';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.673 UTC [93] LOG:  duration: 0.091 ms
postgres  | 2023-09-19 07:30:33.673 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'acl', '004_212_to_213', ARRAY['004_212_to_213'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '004_212_to_213'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '004_212_to_213');
postgres  | 2023-09-19 07:30:33.673 UTC [93] LOG:  duration: 0.140 ms
postgres  | 2023-09-19 07:30:33.673 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "acme_storage" (
postgres  | 	        "id"          UUID   PRIMARY KEY,
postgres  | 	        "key"         TEXT   UNIQUE,
postgres  | 	        "value"       TEXT,
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE,
postgres  | 	        "ttl"         TIMESTAMP WITH TIME ZONE
postgres  | 	      );
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.674 UTC [93] LOG:  duration: 1.419 ms
postgres  | 2023-09-19 07:30:33.675 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'acme', '000_base_acme', ARRAY['000_base_acme'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_acme');
postgres  | 2023-09-19 07:30:33.675 UTC [93] LOG:  duration: 0.162 ms
postgres  | 2023-09-19 07:30:33.675 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE INDEX IF NOT EXISTS "acme_storage_ttl_idx" ON "acme_storage" ("ttl");
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.675 UTC [93] LOG:  duration: 0.482 ms
postgres  | 2023-09-19 07:30:33.675 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'acme', '001_280_to_300', ARRAY['001_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_280_to_300');
postgres  | 2023-09-19 07:30:33.676 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.676 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DROP TRIGGER IF EXISTS "acme_storage_ttl_trigger" ON "acme_storage";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "acme_storage_ttl_trigger"
postgres  | 	        AFTER INSERT ON "acme_storage"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.676 UTC [93] LOG:  duration: 0.285 ms
postgres  | 2023-09-19 07:30:33.676 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'acme', '002_320_to_330', ARRAY['002_320_to_330'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_320_to_330');
postgres  | 2023-09-19 07:30:33.676 UTC [93] LOG:  duration: 0.149 ms
postgres  | 2023-09-19 07:30:33.677 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "basicauth_credentials" (
postgres  | 	        "id"           UUID                         PRIMARY KEY,
postgres  | 	        "created_at"   TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "consumer_id"  UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "username"     TEXT                         UNIQUE,
postgres  | 	        "password"     TEXT
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "basicauth_consumer_id_idx" ON "basicauth_credentials" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.679 UTC [93] LOG:  duration: 2.121 ms
postgres  | 2023-09-19 07:30:33.679 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'basic-auth', '000_base_basic_auth', ARRAY['000_base_basic_auth'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_basic_auth');
postgres  | 2023-09-19 07:30:33.679 UTC [93] LOG:  duration: 0.151 ms
postgres  | 2023-09-19 07:30:33.679 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY basicauth_credentials ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS basicauth_tags_idex_tags_idx ON basicauth_credentials USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS basicauth_sync_tags_trigger ON basicauth_credentials;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER basicauth_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON basicauth_credentials
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.680 UTC [93] LOG:  duration: 0.408 ms
postgres  | 2023-09-19 07:30:33.680 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'basic-auth', '002_130_to_140', ARRAY['002_130_to_140'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_130_to_140');
postgres  | 2023-09-19 07:30:33.680 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.680 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- Add ws_id to basicauth_credentials, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "basicauth_credentials" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "basicauth_credentials" ADD CONSTRAINT "basicauth_credentials_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "basicauth_credentials" DROP CONSTRAINT IF EXISTS "basicauth_credentials_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "basicauth_credentials"
postgres  | 	                        ADD CONSTRAINT "basicauth_credentials_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'basicauth_credentials.username' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "basicauth_credentials" DROP CONSTRAINT IF EXISTS "basicauth_credentials_username_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, username) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "basicauth_credentials" ADD CONSTRAINT "basicauth_credentials_ws_id_username_unique" UNIQUE ("ws_id", "username");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.682 UTC [93] LOG:  duration: 1.797 ms
postgres  | 2023-09-19 07:30:33.682 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'basic-auth', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '003_200_to_210');
postgres  | 2023-09-19 07:30:33.682 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.682 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "basicauth_credentials" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.683 UTC [93] LOG:  duration: 0.188 ms
postgres  | 2023-09-19 07:30:33.683 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'basic-auth', '003_200_to_210', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '003_200_to_210');
postgres  | 2023-09-19 07:30:33.683 UTC [93] LOG:  duration: 0.164 ms
postgres  | 2023-09-19 07:30:33.683 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'bot-detection', ARRAY['001_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_200_to_210');
postgres  | 2023-09-19 07:30:33.683 UTC [93] LOG:  duration: 0.139 ms
postgres  | 2023-09-19 07:30:33.683 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.683 UTC [93] LOG:  duration: 0.057 ms
postgres  | 2023-09-19 07:30:33.684 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'bot-detection', '001_200_to_210', ARRAY['001_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_200_to_210');
postgres  | 2023-09-19 07:30:33.684 UTC [93] LOG:  duration: 0.148 ms
postgres  | 2023-09-19 07:30:33.684 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "hmacauth_credentials" (
postgres  | 	        "id"           UUID                         PRIMARY KEY,
postgres  | 	        "created_at"   TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "consumer_id"  UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "username"     TEXT                         UNIQUE,
postgres  | 	        "secret"       TEXT
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "hmacauth_credentials_consumer_id_idx" ON "hmacauth_credentials" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.686 UTC [93] LOG:  duration: 2.382 ms
postgres  | 2023-09-19 07:30:33.687 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'hmac-auth', '000_base_hmac_auth', ARRAY['000_base_hmac_auth'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_hmac_auth');
postgres  | 2023-09-19 07:30:33.687 UTC [93] LOG:  duration: 0.167 ms
postgres  | 2023-09-19 07:30:33.687 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY hmacauth_credentials ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS hmacauth_tags_idex_tags_idx ON hmacauth_credentials USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS hmacauth_sync_tags_trigger ON hmacauth_credentials;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER hmacauth_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON hmacauth_credentials
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.687 UTC [93] LOG:  duration: 0.430 ms
postgres  | 2023-09-19 07:30:33.687 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'hmac-auth', '002_130_to_140', ARRAY['002_130_to_140'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_130_to_140');
postgres  | 2023-09-19 07:30:33.688 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.688 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- Add ws_id to hmacauth_credentials, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "hmacauth_credentials" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "hmacauth_credentials" ADD CONSTRAINT "hmacauth_credentials_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "hmacauth_credentials" DROP CONSTRAINT IF EXISTS "hmacauth_credentials_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "hmacauth_credentials"
postgres  | 	                        ADD CONSTRAINT "hmacauth_credentials_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'hmacauth_credentials.username' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "hmacauth_credentials" DROP CONSTRAINT IF EXISTS "hmacauth_credentials_username_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, username) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "hmacauth_credentials" ADD CONSTRAINT "hmacauth_credentials_ws_id_username_unique" UNIQUE ("ws_id", "username");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.690 UTC [93] LOG:  duration: 1.958 ms
postgres  | 2023-09-19 07:30:33.690 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'hmac-auth', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '003_200_to_210');
postgres  | 2023-09-19 07:30:33.690 UTC [93] LOG:  duration: 0.149 ms
postgres  | 2023-09-19 07:30:33.690 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "hmacauth_credentials" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.690 UTC [93] LOG:  duration: 0.348 ms
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'hmac-auth', '003_200_to_210', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '003_200_to_210');
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  duration: 0.162 ms
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'http-log', ARRAY['001_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_280_to_300');
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  duration: 0.132 ms
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  duration: 0.059 ms
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'http-log', '001_280_to_300', ARRAY['001_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_280_to_300'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_280_to_300');
postgres  | 2023-09-19 07:30:33.691 UTC [93] LOG:  duration: 0.147 ms
postgres  | 2023-09-19 07:30:33.692 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'ip-restriction', ARRAY['001_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_200_to_210');
postgres  | 2023-09-19 07:30:33.692 UTC [93] LOG:  duration: 0.137 ms
postgres  | 2023-09-19 07:30:33.692 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.692 UTC [93] LOG:  duration: 0.049 ms
postgres  | 2023-09-19 07:30:33.692 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'ip-restriction', '001_200_to_210', ARRAY['001_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_200_to_210');
postgres  | 2023-09-19 07:30:33.692 UTC [93] LOG:  duration: 0.169 ms
postgres  | 2023-09-19 07:30:33.692 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "jwt_secrets" (
postgres  | 	        "id"              UUID                         PRIMARY KEY,
postgres  | 	        "created_at"      TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "consumer_id"     UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "key"             TEXT                         UNIQUE,
postgres  | 	        "secret"          TEXT,
postgres  | 	        "algorithm"       TEXT,
postgres  | 	        "rsa_public_key"  TEXT
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "jwt_secrets_consumer_id_idx" ON "jwt_secrets" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "jwt_secrets_secret_idx" ON "jwt_secrets" ("secret");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.695 UTC [93] LOG:  duration: 2.572 ms
postgres  | 2023-09-19 07:30:33.695 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'jwt', '000_base_jwt', ARRAY['000_base_jwt'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_jwt');
postgres  | 2023-09-19 07:30:33.695 UTC [93] LOG:  duration: 0.154 ms
postgres  | 2023-09-19 07:30:33.695 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY jwt_secrets ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS jwtsecrets_tags_idex_tags_idx ON jwt_secrets USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS jwtsecrets_sync_tags_trigger ON jwt_secrets;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER jwtsecrets_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON jwt_secrets
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.696 UTC [93] LOG:  duration: 0.404 ms
postgres  | 2023-09-19 07:30:33.696 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'jwt', '002_130_to_140', ARRAY['002_130_to_140'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_130_to_140');
postgres  | 2023-09-19 07:30:33.696 UTC [93] LOG:  duration: 0.156 ms
postgres  | 2023-09-19 07:30:33.696 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- Add ws_id to jwt_secrets, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "jwt_secrets" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "jwt_secrets" ADD CONSTRAINT "jwt_secrets_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "jwt_secrets" DROP CONSTRAINT IF EXISTS "jwt_secrets_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "jwt_secrets"
postgres  | 	                        ADD CONSTRAINT "jwt_secrets_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'jwt_secrets.key' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "jwt_secrets" DROP CONSTRAINT IF EXISTS "jwt_secrets_key_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, key) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "jwt_secrets" ADD CONSTRAINT "jwt_secrets_ws_id_key_unique" UNIQUE ("ws_id", "key");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.698 UTC [93] LOG:  duration: 1.968 ms
postgres  | 2023-09-19 07:30:33.698 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'jwt', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '003_200_to_210');
postgres  | 2023-09-19 07:30:33.699 UTC [93] LOG:  duration: 0.153 ms
postgres  | 2023-09-19 07:30:33.699 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "jwt_secrets" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.699 UTC [93] LOG:  duration: 0.187 ms
postgres  | 2023-09-19 07:30:33.699 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'jwt', '003_200_to_210', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '003_200_to_210');
postgres  | 2023-09-19 07:30:33.699 UTC [93] LOG:  duration: 0.153 ms
postgres  | 2023-09-19 07:30:33.699 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "keyauth_credentials" (
postgres  | 	        "id"           UUID                         PRIMARY KEY,
postgres  | 	        "created_at"   TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "consumer_id"  UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "key"          TEXT                         UNIQUE
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "keyauth_credentials_consumer_id_idx" ON "keyauth_credentials" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.701 UTC [93] LOG:  duration: 1.925 ms
postgres  | 2023-09-19 07:30:33.702 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'key-auth', '000_base_key_auth', ARRAY['000_base_key_auth'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_key_auth');
postgres  | 2023-09-19 07:30:33.702 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.702 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY keyauth_credentials ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS keyauth_tags_idex_tags_idx ON keyauth_credentials USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS keyauth_sync_tags_trigger ON keyauth_credentials;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER keyauth_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON keyauth_credentials
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "keyauth_credentials" ADD "ttl" TIMESTAMP WITH TIME ZONE;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS keyauth_credentials_ttl_idx ON keyauth_credentials (ttl);
postgres  | 	      EXCEPTION WHEN UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.703 UTC [93] LOG:  duration: 0.862 ms
postgres  | 2023-09-19 07:30:33.703 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'key-auth', '002_130_to_140', ARRAY['002_130_to_140'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_130_to_140');
postgres  | 2023-09-19 07:30:33.703 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.703 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- Add ws_id to keyauth_credentials, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "keyauth_credentials" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "keyauth_credentials" ADD CONSTRAINT "keyauth_credentials_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "keyauth_credentials" DROP CONSTRAINT IF EXISTS "keyauth_credentials_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "keyauth_credentials"
postgres  | 	                        ADD CONSTRAINT "keyauth_credentials_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'keyauth_credentials.key' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "keyauth_credentials" DROP CONSTRAINT IF EXISTS "keyauth_credentials_key_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, key) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "keyauth_credentials" ADD CONSTRAINT "keyauth_credentials_ws_id_key_unique" UNIQUE ("ws_id", "key");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.705 UTC [93] LOG:  duration: 1.867 ms
postgres  | 2023-09-19 07:30:33.705 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'key-auth', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '003_200_to_210');
postgres  | 2023-09-19 07:30:33.705 UTC [93] LOG:  duration: 0.148 ms
postgres  | 2023-09-19 07:30:33.705 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "keyauth_credentials" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.706 UTC [93] LOG:  duration: 0.186 ms
postgres  | 2023-09-19 07:30:33.706 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'key-auth', '003_200_to_210', ARRAY['003_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '003_200_to_210');
postgres  | 2023-09-19 07:30:33.706 UTC [93] LOG:  duration: 0.214 ms
postgres  | 2023-09-19 07:30:33.706 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DROP TRIGGER IF EXISTS "keyauth_credentials_ttl_trigger" ON "keyauth_credentials";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "keyauth_credentials_ttl_trigger"
postgres  | 	        AFTER INSERT ON "keyauth_credentials"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.706 UTC [93] LOG:  duration: 0.199 ms
postgres  | 2023-09-19 07:30:33.707 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'key-auth', '004_320_to_330', ARRAY['004_320_to_330'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '004_320_to_330');
postgres  | 2023-09-19 07:30:33.707 UTC [93] LOG:  duration: 0.167 ms
postgres  | 2023-09-19 07:30:33.707 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "oauth2_credentials" (
postgres  | 	        "id"             UUID                         PRIMARY KEY,
postgres  | 	        "created_at"     TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "name"           TEXT,
postgres  | 	        "consumer_id"    UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "client_id"      TEXT                         UNIQUE,
postgres  | 	        "client_secret"  TEXT,
postgres  | 	        "redirect_uris"  TEXT[]
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_credentials_consumer_id_idx" ON "oauth2_credentials" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_credentials_secret_idx" ON "oauth2_credentials" ("client_secret");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "oauth2_authorization_codes" (
postgres  | 	        "id"                    UUID                         PRIMARY KEY,
postgres  | 	        "created_at"            TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "credential_id"         UUID                         REFERENCES "oauth2_credentials" ("id") ON DELETE CASCADE,
postgres  | 	        "service_id"            UUID                         REFERENCES "services" ("id") ON DELETE CASCADE,
postgres  | 	        "code"                  TEXT                         UNIQUE,
postgres  | 	        "authenticated_userid"  TEXT,
postgres  | 	        "scope"                 TEXT,
postgres  | 	        "ttl"                   TIMESTAMP WITH TIME ZONE
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_authorization_codes_authenticated_userid_idx" ON "oauth2_authorization_codes" ("authenticated_userid");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_authorization_credential_id_idx"
postgres  | 	                                ON "oauth2_authorization_codes" ("credential_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_authorization_service_id_idx"
postgres  | 	                                ON "oauth2_authorization_codes" ("service_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "oauth2_tokens" (
postgres  | 	        "id"                    UUID                         PRIMARY KEY,
postgres  | 	        "created_at"            TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "credential_id"         UUID                         REFERENCES "oauth2_credentials" ("id") ON DELETE CASCADE,
postgres  | 	        "service_id"            UUID                         REFERENCES "services" ("id") ON DELETE CASCADE,
postgres  | 	        "access_token"          TEXT                         UNIQUE,
postgres  | 	        "refresh_token"         TEXT                         UNIQUE,
postgres  | 	        "token_type"            TEXT,
postgres  | 	        "expires_in"            INTEGER,
postgres  | 	        "authenticated_userid"  TEXT,
postgres  | 	        "scope"                 TEXT,
postgres  | 	        "ttl"                   TIMESTAMP WITH TIME ZONE
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_tokens_authenticated_userid_idx" ON "oauth2_tokens" ("authenticated_userid");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_tokens_credential_id_idx"
postgres  | 	                                ON "oauth2_tokens" ("credential_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "oauth2_tokens_service_id_idx"
postgres  | 	                                ON "oauth2_tokens" ("service_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.715 UTC [93] LOG:  duration: 8.624 ms
postgres  | 2023-09-19 07:30:33.716 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'oauth2', '000_base_oauth2', ARRAY['000_base_oauth2'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_oauth2');
postgres  | 2023-09-19 07:30:33.716 UTC [93] LOG:  duration: 0.170 ms
postgres  | 2023-09-19 07:30:33.716 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY oauth2_credentials ADD tags TEXT[];
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS oauth2_credentials_tags_idex_tags_idx ON oauth2_credentials USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS oauth2_credentials_sync_tags_trigger ON oauth2_credentials;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER oauth2_credentials_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON oauth2_credentials
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS oauth2_authorization_codes_ttl_idx ON oauth2_authorization_codes (ttl);
postgres  | 	      EXCEPTION WHEN UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS oauth2_tokens_ttl_idx ON oauth2_tokens (ttl);
postgres  | 	      EXCEPTION WHEN UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.717 UTC [93] LOG:  duration: 1.436 ms
postgres  | 2023-09-19 07:30:33.718 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'oauth2', '003_130_to_140', ARRAY['003_130_to_140'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_130_to_140');
postgres  | 2023-09-19 07:30:33.718 UTC [93] LOG:  duration: 0.129 ms
postgres  | 2023-09-19 07:30:33.718 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" ADD "challenge" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" ADD "challenge_method" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "oauth2_credentials" ADD "client_type" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY oauth2_credentials ADD hash_secret BOOLEAN;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	            -- Add ws_id to oauth2_credentials, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "oauth2_credentials" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_credentials" ADD CONSTRAINT "oauth2_credentials_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_credentials" DROP CONSTRAINT IF EXISTS "oauth2_credentials_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_credentials"
postgres  | 	                        ADD CONSTRAINT "oauth2_credentials_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'oauth2_credentials.client_id' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_credentials" DROP CONSTRAINT IF EXISTS "oauth2_credentials_client_id_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, client_id) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_credentials" ADD CONSTRAINT "oauth2_credentials_ws_id_client_id_unique" UNIQUE ("ws_id", "client_id");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to oauth2_authorization_codes, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" ADD CONSTRAINT "oauth2_authorization_codes_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" DROP CONSTRAINT IF EXISTS "oauth2_authorization_codes_service_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes"
postgres  | 	                        ADD CONSTRAINT "oauth2_authorization_codes_service_id_fkey"
postgres  | 	                           FOREIGN KEY ("service_id", "ws_id")
postgres  | 	                            REFERENCES services("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" DROP CONSTRAINT IF EXISTS "oauth2_authorization_codes_credential_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes"
postgres  | 	                        ADD CONSTRAINT "oauth2_authorization_codes_credential_id_fkey"
postgres  | 	                           FOREIGN KEY ("credential_id", "ws_id")
postgres  | 	                            REFERENCES oauth2_credentials("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'oauth2_authorization_codes.code' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" DROP CONSTRAINT IF EXISTS "oauth2_authorization_codes_code_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, code) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" ADD CONSTRAINT "oauth2_authorization_codes_ws_id_code_unique" UNIQUE ("ws_id", "code");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to oauth2_tokens, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "oauth2_tokens" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_tokens" ADD CONSTRAINT "oauth2_tokens_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_tokens" DROP CONSTRAINT IF EXISTS "oauth2_tokens_service_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_tokens"
postgres  | 	                        ADD CONSTRAINT "oauth2_tokens_service_id_fkey"
postgres  | 	                           FOREIGN KEY ("service_id", "ws_id")
postgres  | 	                            REFERENCES services("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_tokens" DROP CONSTRAINT IF EXISTS "oauth2_tokens_credential_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_tokens"
postgres  | 	                        ADD CONSTRAINT "oauth2_tokens_credential_id_fkey"
postgres  | 	                           FOREIGN KEY ("credential_id", "ws_id")
postgres  | 	                            REFERENCES oauth2_credentials("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'oauth2_tokens.access_token' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_tokens" DROP CONSTRAINT IF EXISTS "oauth2_tokens_access_token_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, access_token) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_tokens" ADD CONSTRAINT "oauth2_tokens_ws_id_access_token_unique" UNIQUE ("ws_id", "access_token");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'oauth2_tokens.refresh_token' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "oauth2_tokens" DROP CONSTRAINT IF EXISTS "oauth2_tokens_refresh_token_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, refresh_token) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "oauth2_tokens" ADD CONSTRAINT "oauth2_tokens_ws_id_refresh_token_unique" UNIQUE ("ws_id", "refresh_token");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.725 UTC [93] LOG:  duration: 6.937 ms
postgres  | 2023-09-19 07:30:33.725 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'oauth2', ARRAY['004_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '004_200_to_210');
postgres  | 2023-09-19 07:30:33.725 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.725 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "oauth2_credentials" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.725 UTC [93] LOG:  duration: 0.177 ms
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  duration: 0.166 ms
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  statement:         ALTER TABLE IF EXISTS ONLY "oauth2_tokens" ALTER "ws_id" SET DEFAULT NULL;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  duration: 0.163 ms
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'oauth2', '004_200_to_210', ARRAY['004_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '004_200_to_210'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '004_200_to_210');
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  duration: 0.139 ms
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  statement: BEGIN;
postgres  | 	SELECT 1;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.726 UTC [93] LOG:  duration: 0.033 ms
postgres  | 2023-09-19 07:30:33.727 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'oauth2', '005_210_to_211', ARRAY['005_210_to_211'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '005_210_to_211');
postgres  | 2023-09-19 07:30:33.727 UTC [93] LOG:  duration: 0.130 ms
postgres  | 2023-09-19 07:30:33.727 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DROP TRIGGER IF EXISTS "oauth2_authorization_codes_ttl_trigger" ON "oauth2_authorization_codes";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "oauth2_authorization_codes_ttl_trigger"
postgres  | 	        AFTER INSERT ON "oauth2_authorization_codes"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      DROP TRIGGER IF EXISTS "oauth2_tokens_ttl_trigger" ON "oauth2_tokens";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "oauth2_tokens_ttl_trigger"
postgres  | 	        AFTER INSERT ON "oauth2_tokens"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.727 UTC [93] LOG:  duration: 0.280 ms
postgres  | 2023-09-19 07:30:33.727 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'oauth2', '006_320_to_330', ARRAY['006_320_to_330'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '006_320_to_330');
postgres  | 2023-09-19 07:30:33.727 UTC [93] LOG:  duration: 0.129 ms
postgres  | 2023-09-19 07:30:33.727 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "oauth2_authorization_codes" ADD "plugin_id" UUID REFERENCES "plugins" ("id") ON DELETE CASCADE;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.728 UTC [93] LOG:  duration: 0.280 ms
postgres  | 2023-09-19 07:30:33.728 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'oauth2', '007_320_to_330', ARRAY['007_320_to_330'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '007_320_to_330');
postgres  | 2023-09-19 07:30:33.728 UTC [93] LOG:  duration: 0.122 ms
postgres  | 2023-09-19 07:30:33.728 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.728 UTC [93] LOG:  duration: 0.085 ms
postgres  | 2023-09-19 07:30:33.728 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'post-function', ARRAY['001_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_280_to_300');
postgres  | 2023-09-19 07:30:33.729 UTC [93] LOG:  duration: 0.278 ms
postgres  | 2023-09-19 07:30:33.729 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.729 UTC [93] LOG:  duration: 0.053 ms
postgres  | 2023-09-19 07:30:33.729 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'post-function', '001_280_to_300', ARRAY['001_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_280_to_300'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_280_to_300');
postgres  | 2023-09-19 07:30:33.729 UTC [93] LOG:  duration: 0.149 ms
postgres  | 2023-09-19 07:30:33.729 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.729 UTC [93] LOG:  duration: 0.050 ms
postgres  | 2023-09-19 07:30:33.730 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'pre-function', ARRAY['001_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_280_to_300');
postgres  | 2023-09-19 07:30:33.730 UTC [93] LOG:  duration: 0.124 ms
postgres  | 2023-09-19 07:30:33.730 UTC [93] LOG:  statement: SELECT id, name, config FROM plugins
postgres  | 2023-09-19 07:30:33.730 UTC [93] LOG:  duration: 0.046 ms
postgres  | 2023-09-19 07:30:33.730 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'pre-function', '001_280_to_300', ARRAY['001_280_to_300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_280_to_300'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_280_to_300');
postgres  | 2023-09-19 07:30:33.730 UTC [93] LOG:  duration: 0.126 ms
postgres  | 2023-09-19 07:30:33.730 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "ratelimiting_metrics" (
postgres  | 	        "identifier"   TEXT                         NOT NULL,
postgres  | 	        "period"       TEXT                         NOT NULL,
postgres  | 	        "period_date"  TIMESTAMP WITH TIME ZONE     NOT NULL,
postgres  | 	        "service_id"   UUID                         NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000'::UUID,
postgres  | 	        "route_id"     UUID                         NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000'::UUID,
postgres  | 	        "value"        INTEGER,
postgres  | 	
postgres  | 	        PRIMARY KEY ("identifier", "period", "period_date", "service_id", "route_id")
postgres  | 	      );
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.731 UTC [93] LOG:  duration: 1.159 ms
postgres  | 2023-09-19 07:30:33.732 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'rate-limiting', '000_base_rate_limiting', ARRAY['000_base_rate_limiting'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_rate_limiting');
postgres  | 2023-09-19 07:30:33.732 UTC [93] LOG:  duration: 0.149 ms
postgres  | 2023-09-19 07:30:33.732 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE INDEX IF NOT EXISTS ratelimiting_metrics_idx ON ratelimiting_metrics (service_id, route_id, period_date, period);
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.732 UTC [93] LOG:  duration: 0.517 ms
postgres  | 2023-09-19 07:30:33.733 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'rate-limiting', '003_10_to_112', ARRAY['003_10_to_112'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '003_10_to_112');
postgres  | 2023-09-19 07:30:33.733 UTC [93] LOG:  duration: 0.198 ms
postgres  | 2023-09-19 07:30:33.733 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "ratelimiting_metrics" ADD "ttl" TIMESTAMP WITH TIME ZONE;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "ratelimiting_metrics_ttl_idx" ON "ratelimiting_metrics" ("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.733 UTC [93] LOG:  duration: 0.568 ms
postgres  | 2023-09-19 07:30:33.734 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'rate-limiting', '004_200_to_210', ARRAY['004_200_to_210'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '004_200_to_210');
postgres  | 2023-09-19 07:30:33.734 UTC [93] LOG:  duration: 0.137 ms
postgres  | 2023-09-19 07:30:33.734 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DROP TRIGGER IF EXISTS "ratelimiting_metrics_ttl_trigger" ON "ratelimiting_metrics";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "ratelimiting_metrics_ttl_trigger"
postgres  | 	        AFTER INSERT ON "ratelimiting_metrics"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.734 UTC [93] LOG:  duration: 0.213 ms
postgres  | 2023-09-19 07:30:33.734 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'rate-limiting', '005_320_to_330', ARRAY['005_320_to_330'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '005_320_to_330');
postgres  | 2023-09-19 07:30:33.734 UTC [93] LOG:  duration: 0.135 ms
postgres  | 2023-09-19 07:30:33.734 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "response_ratelimiting_metrics" (
postgres  | 	        "identifier"   TEXT                         NOT NULL,
postgres  | 	        "period"       TEXT                         NOT NULL,
postgres  | 	        "period_date"  TIMESTAMP WITH TIME ZONE     NOT NULL,
postgres  | 	        "service_id"   UUID                         NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000'::uuid,
postgres  | 	        "route_id"     UUID                         NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000'::uuid,
postgres  | 	        "value"        INTEGER,
postgres  | 	
postgres  | 	        PRIMARY KEY ("identifier", "period", "period_date", "service_id", "route_id")
postgres  | 	      );
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.736 UTC [93] LOG:  duration: 1.063 ms
postgres  | 2023-09-19 07:30:33.736 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'response-ratelimiting', '000_base_response_rate_limiting', ARRAY['000_base_response_rate_limiting'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_response_rate_limiting');
postgres  | 2023-09-19 07:30:33.736 UTC [93] LOG:  duration: 0.135 ms
postgres  | 2023-09-19 07:30:33.736 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS sessions(
postgres  | 	        id            uuid,
postgres  | 	        session_id    text UNIQUE,
postgres  | 	        expires       int,
postgres  | 	        data          text,
postgres  | 	        created_at    timestamp WITH TIME ZONE,
postgres  | 	        ttl           timestamp WITH TIME ZONE,
postgres  | 	        PRIMARY KEY (id)
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "session_sessions_expires_idx" ON "sessions" ("expires");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.738 UTC [93] LOG:  duration: 1.844 ms
postgres  | 2023-09-19 07:30:33.738 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'session', '000_base_session', ARRAY['000_base_session'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base_session');
postgres  | 2023-09-19 07:30:33.738 UTC [93] LOG:  duration: 0.141 ms
postgres  | 2023-09-19 07:30:33.738 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE INDEX IF NOT EXISTS sessions_ttl_idx ON sessions (ttl);
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.739 UTC [93] LOG:  duration: 0.488 ms
postgres  | 2023-09-19 07:30:33.739 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'session', '001_add_ttl_index', ARRAY['001_add_ttl_index'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_add_ttl_index');
postgres  | 2023-09-19 07:30:33.739 UTC [93] LOG:  duration: 0.133 ms
postgres  | 2023-09-19 07:30:33.739 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DROP TRIGGER IF EXISTS "sessions_ttl_trigger" ON "sessions";
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER "sessions_ttl_trigger"
postgres  | 	        AFTER INSERT ON "sessions"
postgres  | 	        FOR EACH STATEMENT
postgres  | 	        EXECUTE PROCEDURE batch_delete_expired_rows("ttl");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.739 UTC [93] LOG:  duration: 0.201 ms
postgres  | 2023-09-19 07:30:33.739 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'session', '002_320_to_330', ARRAY['002_320_to_330'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_320_to_330');
postgres  | 2023-09-19 07:30:33.740 UTC [93] LOG:  duration: 0.138 ms
postgres  | 2023-09-19 07:30:33.740 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS rl_counters(
postgres  | 	        key          text,
postgres  | 	        namespace    text,
postgres  | 	        window_start int,
postgres  | 	        window_size  int,
postgres  | 	        count        int,
postgres  | 	        PRIMARY KEY(key, namespace, window_start, window_size)
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        IF (SELECT to_regclass('sync_key_idx')) IS NULL THEN
postgres  | 	          CREATE INDEX sync_key_idx ON rl_counters(namespace, window_start);
postgres  | 	        END IF;
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_stats_hours(
postgres  | 	          at integer,
postgres  | 	          l2_hit integer default 0,
postgres  | 	          l2_miss integer default 0,
postgres  | 	          plat_min integer,
postgres  | 	          plat_max integer,
postgres  | 	          PRIMARY KEY (at)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_stats_seconds(
postgres  | 	          node_id uuid,
postgres  | 	          at integer,
postgres  | 	          l2_hit integer default 0,
postgres  | 	          l2_miss integer default 0,
postgres  | 	          plat_min integer,
postgres  | 	          plat_max integer,
postgres  | 	          ulat_min integer,
postgres  | 	          ulat_max integer,
postgres  | 	          requests integer default 0,
postgres  | 	          plat_count int default 0,
postgres  | 	          plat_total int default 0,
postgres  | 	          ulat_count int default 0,
postgres  | 	          ulat_total int default 0,
postgres  | 	          PRIMARY KEY (node_id, at)
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_stats_minutes
postgres  | 	      (LIKE vitals_stats_seconds INCLUDING defaults INCLUDING constraints INCLUDING indexes);
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_node_meta(
postgres  | 	        node_id uuid PRIMARY KEY,
postgres  | 	        first_report timestamp without time zone,
postgres  | 	        last_report timestamp without time zone,
postgres  | 	        hostname text
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_code_classes_by_cluster(
postgres  | 	        code_class int,
postgres  | 	        at timestamp with time zone,
postgres  | 	        duration int,
postgres  | 	        count int,
postgres  | 	        PRIMARY KEY (code_class, duration, at)
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_codes_by_route(
postgres  | 	        service_id uuid,
postgres  | 	        route_id uuid,
postgres  | 	        code int,
postgres  | 	        at timestamp with time zone,
postgres  | 	        duration int,
postgres  | 	        count int,
postgres  | 	        PRIMARY KEY (route_id, code, duration, at)
postgres  | 	      ) WITH (autovacuum_vacuum_scale_factor='0.01', autovacuum_analyze_scale_factor='0.01');
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS vcbr_svc_ts_idx
postgres  | 	      ON vitals_codes_by_route(service_id, duration, at);
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_codes_by_consumer_route(
postgres  | 	        consumer_id uuid,
postgres  | 	        service_id uuid,
postgres  | 	        route_id uuid,
postgres  | 	        code int,
postgres  | 	        at timestamp with time zone,
postgres  | 	        duration int,
postgres  | 	        count int,
postgres  | 	        PRIMARY KEY (consumer_id, route_id, code, duration, at)
postgres  | 	      ) WITH (autovacuum_vacuum_scale_factor='0.01', autovacuum_analyze_scale_factor='0.01');
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_code_classes_by_workspace(
postgres  | 	        workspace_id uuid,
postgres  | 	        code_class int,
postgres  | 	        at timestamp with time zone,
postgres  | 	        duration int,
postgres  | 	        count int,
postgres  | 	        PRIMARY KEY (workspace_id, code_class, duration, at)
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_locks(
postgres  | 	        key text,
postgres  | 	        expiry timestamp with time zone,
postgres  | 	        PRIMARY KEY(key)
postgres  | 	      );
postgres  | 	      INSERT INTO vitals_locks(key, expiry)
postgres  | 	      VALUES ('delete_status_codes', NULL) ON CONFLICT DO NOTHING;
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS workspaces (
postgres  | 	        id  UUID                  PRIMARY KEY,
postgres  | 	        name                      TEXT                      UNIQUE,
postgres  | 	        comment                   TEXT,
postgres  | 	        created_at                TIMESTAMP WITH TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        meta                      JSON                      DEFAULT '{}'::json,
postgres  | 	        config                    JSON                      DEFAULT '{"portal":false}'::json
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS workspace_entities(
postgres  | 	        workspace_id uuid,
postgres  | 	        workspace_name text,
postgres  | 	        entity_id text,
postgres  | 	        entity_type text,
postgres  | 	        unique_field_name text,
postgres  | 	        unique_field_value text,
postgres  | 	        PRIMARY KEY(workspace_id, entity_id, unique_field_name)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS workspace_entities_idx_entity_id ON workspace_entities(entity_id);
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        IF (SELECT to_regclass('workspace_entities_composite_idx')) IS NULL THEN
postgres  | 	          CREATE INDEX workspace_entities_composite_idx on workspace_entities(workspace_id, entity_type, unique_field_name);
postgres  | 	        END IF;
postgres  | 	      END$$;
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS workspace_entity_counters(
postgres  | 	        workspace_id uuid REFERENCES workspaces (id) ON DELETE CASCADE,
postgres  | 	        entity_type text,
postgres  | 	        count int,
postgres  | 	        PRIMARY KEY(workspace_id, entity_type)
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS rbac_users(
postgres  | 	        id uuid PRIMARY KEY,
postgres  | 	        name text UNIQUE NOT NULL,
postgres  | 	        user_token text UNIQUE NOT NULL,
postgres  | 	        user_token_ident text,
postgres  | 	        comment text,
postgres  | 	        enabled boolean NOT NULL,
postgres  | 	        created_at timestamp WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC')
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        IF (SELECT to_regclass('rbac_users_name_idx')) IS NULL THEN
postgres  | 	          CREATE INDEX rbac_users_name_idx on rbac_users(name);
postgres  | 	        END IF;
postgres  | 	        IF (SELECT to_regclass('rbac_users_token_idx')) IS NULL THEN
postgres  | 	          CREATE INDEX rbac_users_token_idx on rbac_users(user_token);
postgres  | 	        END IF;
postgres  | 	        IF (SELECT to_regclass('rbac_token_ident_idx')) IS NULL THEN
postgres  | 	          CREATE INDEX rbac_token_ident_idx on rbac_users(user_token_ident);
postgres  | 	        END IF;
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS rbac_roles(
postgres  | 	        id uuid PRIMARY KEY,
postgres  | 	        name text UNIQUE NOT NULL,
postgres  | 	        comment text,
postgres  | 	        created_at timestamp WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        is_default boolean default false
postgres  | 	      );
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS rbac_user_roles(
postgres  | 	        user_id uuid NOT NULL REFERENCES rbac_users(id) ON DELETE CASCADE,
postgres  | 	        role_id uuid NOT NULL REFERENCES rbac_roles(id) ON DELETE CASCADE,
postgres  | 	        PRIMARY KEY(user_id, role_id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS rbac_roles_name_idx on rbac_roles(name);
postgres  | 	      CREATE INDEX IF NOT EXISTS rbac_role_default_idx on rbac_roles(is_default);
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS rbac_role_entities(
postgres  | 	        role_id uuid REFERENCES rbac_roles(id) ON DELETE CASCADE,
postgres  | 	        entity_id text,
postgres  | 	        entity_type text NOT NULL,
postgres  | 	        actions smallint NOT NULL,
postgres  | 	        negative boolean NOT NULL,
postgres  | 	        comment text,
postgres  | 	        created_at                TIMESTAMP WITH TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        PRIMARY KEY(role_id, entity_id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS rbac_role_entities_role_idx on rbac_role_entities(role_id);
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS rbac_role_endpoints(
postgres  | 	        role_id uuid,
postgres  | 	        workspace text NOT NULL,
postgres  | 	        endpoint text NOT NULL,
postgres  | 	        actions smallint NOT NULL,
postgres  | 	        comment text,
postgres  | 	        created_at                TIMESTAMP WITH TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        negative boolean NOT NULL,
postgres  | 	        PRIMARY KEY(role_id, workspace, endpoint),
postgres  | 	        FOREIGN KEY (role_id) REFERENCES rbac_roles(id) ON DELETE CASCADE
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS rbac_role_endpoints_role_idx on rbac_role_endpoints(role_id);
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS files(
postgres  | 	        id uuid PRIMARY KEY,
postgres  | 	        path text UNIQUE NOT NULL,
postgres  | 	        checksum text,
postgres  | 	        contents text,
postgres  | 	        created_at timestamp without time zone default (CURRENT_TIMESTAMP(0) at time zone 'utc')
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS files_path_idx on files(path);
postgres  | 	
postgres  | 	      -- XXX
postgres  | 	      -- this table comes from a migration from the future. At this step is
postgres  | 	      -- going to always be empty, but there's already code supporting this
postgres  | 	      -- table so I guess we need it here?
postgres  | 	      CREATE TABLE IF NOT EXISTS legacy_files(
postgres  | 	        id uuid PRIMARY KEY,
postgres  | 	        auth boolean NOT NULL,
postgres  | 	        name text UNIQUE NOT NULL,
postgres  | 	        type text NOT NULL,
postgres  | 	        contents text,
postgres  | 	        created_at timestamp without time zone default (CURRENT_TIMESTAMP(0) at time zone 'utc')
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS legacy_files_name_idx on legacy_files(name);
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        IF not EXISTS (SELECT column_name
postgres  | 	               FROM information_schema.columns
postgres  | 	               WHERE table_schema=current_schema() and table_name='consumers' and column_name='type') THEN
postgres  | 	          ALTER TABLE consumers
postgres  | 	            ADD COLUMN type int NOT NULL DEFAULT 0;
postgres  | 	         END IF;
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS consumers_type_idx
postgres  | 	        ON consumers (type);
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS credentials (
postgres  | 	        id                uuid PRIMARY KEY,
postgres  | 	        consumer_id       uuid REFERENCES consumers (id) ON DELETE CASCADE,
postgres  | 	        consumer_type     integer,
postgres  | 	        plugin            text NOT NULL,
postgres  | 	        credential_data   json,
postgres  | 	        created_at        timestamp without time zone DEFAULT timezone('utc'::text, ('now'::text)::timestamp(0) with time zone)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS credentials_consumer_type
postgres  | 	        ON credentials (consumer_id);
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS credentials_consumer_id_plugin
postgres  | 	        ON credentials (consumer_id, plugin);
postgres  | 	
postgres  | 	
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS consumer_reset_secrets(
postgres  | 	        id uuid PRIMARY KEY,
postgres  | 	        consumer_id uuid REFERENCES consumers (id) ON DELETE CASCADE,
postgres  | 	        secret text,
postgres  | 	        status integer,
postgres  | 	        client_addr text,
postgres  | 	        created_at timestamp without time zone default (CURRENT_TIMESTAMP(0) at time zone 'utc'),
postgres  | 	        updated_at timestamp without time zone default (CURRENT_TIMESTAMP(0) at time zone 'utc')
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS consumer_reset_secrets_consumer_id_idx
postgres  | 	        ON consumer_reset_secrets(consumer_id);
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS admins (
postgres  | 	        id          uuid,
postgres  | 	        created_at  TIMESTAMP WITHOUT TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        updated_at  TIMESTAMP WITHOUT TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        consumer_id  uuid references consumers (id),
postgres  | 	        rbac_user_id  uuid references rbac_users (id),
postgres  | 	        rbac_token_enabled BOOLEAN NOT NULL,
postgres  | 	        email text,
postgres  | 	        status int,
postgres  | 	        username text unique,
postgres  | 	        custom_id text unique,
postgres  | 	        PRIMARY KEY(id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS developers (
postgres  | 	        id          uuid,
postgres  | 	        created_at  timestamp,
postgres  | 	        updated_at  timestamp,
postgres  | 	        email text  unique,
postgres  | 	        status int,
postgres  | 	        meta text,
postgres  | 	        custom_id text unique,
postgres  | 	        consumer_id  uuid references consumers (id) on delete cascade,
postgres  | 	        rbac_user_id uuid,
postgres  | 	        PRIMARY KEY(id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS developers_rbac_user_id_idx ON developers(rbac_user_id);
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS audit_objects(
postgres  | 	        id uuid PRIMARY KEY,
postgres  | 	        request_id char(32),
postgres  | 	        entity_key uuid,
postgres  | 	        dao_name text NOT NULL,
postgres  | 	        operation char(6) NOT NULL,
postgres  | 	        entity text,
postgres  | 	        rbac_user_id uuid,
postgres  | 	        signature text,
postgres  | 	        ttl timestamp with time zone default (CURRENT_TIMESTAMP(0) at time zone 'utc' + interval '2592000')
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS audit_requests(
postgres  | 	        request_id char(32) PRIMARY KEY,
postgres  | 	        request_timestamp timestamp without time zone default (CURRENT_TIMESTAMP(3) at time zone 'utc'),
postgres  | 	        client_ip text NOT NULL,
postgres  | 	        path text NOT NULL,
postgres  | 	        method text NOT NULL,
postgres  | 	        payload text,
postgres  | 	        status integer NOT NULL,
postgres  | 	        rbac_user_id uuid,
postgres  | 	        workspace uuid,
postgres  | 	        signature text,
postgres  | 	        ttl timestamp with time zone default (CURRENT_TIMESTAMP(0) at time zone 'utc' + interval '2592000')
postgres  | 	      );
postgres  | 	
postgres  | 	      -- Groups Entity
postgres  | 	      CREATE TABLE IF NOT EXISTS groups (
postgres  | 	        id          uuid,
postgres  | 	        created_at  TIMESTAMP WITHOUT TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        name text unique,
postgres  | 	        comment text,
postgres  | 	        PRIMARY KEY (id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS groups_name_idx ON groups(name);
postgres  | 	
postgres  | 	      -- Group and RBAC_Role Mapping
postgres  | 	      CREATE TABLE IF NOT EXISTS group_rbac_roles(
postgres  | 	        created_at  TIMESTAMP WITHOUT TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        group_id uuid REFERENCES groups (id) ON DELETE CASCADE,
postgres  | 	        rbac_role_id uuid REFERENCES rbac_roles (id) ON DELETE CASCADE,
postgres  | 	        workspace_id uuid REFERENCES workspaces (id) ON DELETE CASCADE,
postgres  | 	        PRIMARY KEY (group_id, rbac_role_id)
postgres  | 	      );
postgres  | 	
postgres  | 	      -- License data
postgres  | 	      CREATE TABLE IF NOT EXISTS license_data (
postgres  | 	        node_id         uuid,
postgres  | 	        req_cnt         bigint,
postgres  | 	        PRIMARY KEY (node_id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS license_data_key_idx ON license_data(node_id);
postgres  | 	
postgres  | 	      -- Login Attempts
postgres  | 	      CREATE TABLE IF NOT EXISTS login_attempts (
postgres  | 	        consumer_id uuid REFERENCES consumers (id) ON DELETE CASCADE,
postgres  | 	        attempts json DEFAULT '{}'::json,
postgres  | 	        ttl         TIMESTAMP WITH TIME ZONE,
postgres  | 	        created_at  TIMESTAMP WITHOUT TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        PRIMARY KEY (consumer_id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS keyring_meta (
postgres  | 	        id text PRIMARY KEY,
postgres  | 	        state text not null,
postgres  | 	        created_at timestamp with time zone not null
postgres  | 	      );
postgres  | 	
postgres  | 	    -- reentrant, do not seed if it looks seeded
postgres  | 	 DO $$
postgres  | 	         DECLARE tmp record;
postgres  | 	         BEGIN
postgres  | 	         SELECT * into tmp FROM workspace_entities LIMIT 1;
postgres  | 	         IF NOT FOUND THEN
postgres  | 	      
postgres  | 	-- seed kong enterprise data
postgres  | 	
postgres  | 	-- add default workspace
postgres  | 	      INSERT INTO workspaces(id, name) VALUES ('7225b4f1-d5a0-4a4d-b79d-9de491944c52', 'default') ON CONFLICT DO NOTHING;
postgres  | 	    
postgres  | 	
postgres  | 	-- add default RBAC roles
postgres  | 	-- read only role
postgres  | 	INSERT INTO rbac_roles(id, name, comment, is_default) VALUES ('834982a1-9fd4-4122-99e4-e7dee3ac6b72', 'default:read-only', 'Read access to all endpoints, across all workspaces', false);
postgres  | 	INSERT INTO workspace_entities(workspace_id, workspace_name, entity_id, entity_type, unique_field_name, unique_field_value) VALUES ((select id from workspaces where name = 'default' limit 1)::uuid, 'default', '834982a1-9fd4-4122-99e4-e7dee3ac6b72', 'rbac_roles', 'id', '834982a1-9fd4-4122-99e4-e7dee3ac6b72');
postgres  | 	INSERT INTO workspace_entities(workspace_id, workspace_name, entity_id, entity_type, unique_field_name, unique_field_value) VALUES ((select id from workspaces where name = 'default' limit 1)::uuid, 'default', '834982a1-9fd4-4122-99e4-e7dee3ac6b72', 'rbac_roles', 'name', 'default:read-only');
postgres  | 	-- admin role
postgres  | 	INSERT INTO rbac_roles(id, name, comment, is_default) VALUES ('57abe9e3-ba39-4872-aa95-cf8598d92f0e', 'default:admin', 'Full access to all endpoints, across all workspacesexcept RBAC Admin API', false);
postgres  | 	INSERT INTO workspace_entities(workspace_id, workspace_name, entity_id, entity_type, unique_field_name, unique_field_value) VALUES ((select id from workspaces where name = 'default' limit 1)::uuid, 'default', '57abe9e3-ba39-4872-aa95-cf8598d92f0e', 'rbac_roles', 'id', '57abe9e3-ba39-4872-aa95-cf8598d92f0e');
postgres  | 	INSERT INTO workspace_entities(workspace_id, workspace_name, entity_id, entity_type, unique_field_name, unique_field_value) VALUES ((select id from workspaces where name = 'default' limit 1)::uuid, 'default', '57abe9e3-ba39-4872-aa95-cf8598d92f0e', 'rbac_roles', 'name', 'default:admin');
postgres  | 	-- super admin role
postgres  | 	INSERT INTO rbac_roles(id, name, comment, is_default) VALUES ('355f32c7-6769-42f8-9c8a-7ed7d7586ae3', 'default:super-admin', 'Full access to all endpoints, across all workspaces', false);
postgres  | 	INSERT INTO workspace_entities(workspace_id, workspace_name, entity_id, entity_type, unique_field_name, unique_field_value) VALUES ((select id from workspaces where name = 'default' limit 1)::uuid, 'default', '355f32c7-6769-42f8-9c8a-7ed7d7586ae3', 'rbac_roles', 'id', '355f32c7-6769-42f8-9c8a-7ed7d7586ae3');
postgres  | 	INSERT INTO workspace_entities(workspace_id, workspace_name, entity_id, entity_type, unique_field_name, unique_field_value) VALUES ((select id from workspaces where name = 'default' limit 1)::uuid, 'default', '355f32c7-6769-42f8-9c8a-7ed7d7586ae3', 'rbac_roles', 'name', 'default:super-admin');
postgres  | 	-- add default rbac role endpoints
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('834982a1-9fd4-4122-99e4-e7dee3ac6b72', '*', '*', 1, false);
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('57abe9e3-ba39-4872-aa95-cf8598d92f0e', '*', '*', 15, false);
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('57abe9e3-ba39-4872-aa95-cf8598d92f0e', '*', '/rbac/*', 15, true);
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('57abe9e3-ba39-4872-aa95-cf8598d92f0e', '*', '/rbac/*/*', 15, true);
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('57abe9e3-ba39-4872-aa95-cf8598d92f0e', '*', '/rbac/*/*/*', 15, true);
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('57abe9e3-ba39-4872-aa95-cf8598d92f0e', '*', '/rbac/*/*/*/*', 15, true);
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('57abe9e3-ba39-4872-aa95-cf8598d92f0e', '*', '/rbac/*/*/*/*/*', 15, true);
postgres  | 	INSERT INTO rbac_role_endpoints(role_id, workspace, endpoint, actions, negative) VALUES ('355f32c7-6769-42f8-9c8a-7ed7d7586ae3', '*', '*', 15, false);
postgres  | 	END IF;
postgres  | 	END $$;
postgres  | 	-- end      -- The end;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.782 UTC [93] LOG:  duration: 42.713 ms
postgres  | 2023-09-19 07:30:33.783 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '000_base', ARRAY['000_base'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '000_base');
postgres  | 2023-09-19 07:30:33.783 UTC [93] LOG:  duration: 0.254 ms
postgres  | 2023-09-19 07:30:33.783 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS applications (
postgres  | 	        id          uuid,
postgres  | 	        created_at  timestamp,
postgres  | 	        updated_at  timestamp,
postgres  | 	        name text,
postgres  | 	        description text,
postgres  | 	        redirect_uri text,
postgres  | 	        meta text,
postgres  | 	        developer_id uuid references developers (id) on delete cascade,
postgres  | 	        consumer_id  uuid references consumers (id) on delete cascade,
postgres  | 	        PRIMARY KEY(id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE INDEX IF NOT EXISTS applications_developer_id_idx ON applications(developer_id);
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS application_instances (
postgres  | 	        id          uuid,
postgres  | 	        created_at  timestamp,
postgres  | 	        updated_at  timestamp,
postgres  | 	        status int,
postgres  | 	        service_id uuid references services (id) on delete cascade,
postgres  | 	        application_id  uuid references applications (id) on delete cascade,
postgres  | 	        composite_id text unique,
postgres  | 	        suspended boolean NOT NULL,
postgres  | 	        PRIMARY KEY(id)
postgres  | 	      );
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS document_objects (
postgres  | 	        id          uuid,
postgres  | 	        created_at  timestamp,
postgres  | 	        updated_at  timestamp,
postgres  | 	        service_id uuid references services (id) on delete cascade,
postgres  | 	        path text unique,
postgres  | 	        PRIMARY KEY(id)
postgres  | 	      );
postgres  | 	
postgres  | 	      -- XXX: EE keep run_on for now
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "plugins" ADD "run_on" TEXT;
postgres  | 	      EXCEPTION WHEN duplicate_column THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "event_hooks" (
postgres  | 	        "id"           UUID                         UNIQUE,
postgres  | 	        "created_at"   TIMESTAMP WITHOUT TIME ZONE  DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "source"       TEXT NOT NULL,
postgres  | 	        "event"        TEXT,
postgres  | 	        "handler"      TEXT NOT NULL,
postgres  | 	        "on_change"    BOOLEAN,
postgres  | 	        "snooze"       INTEGER,
postgres  | 	        "config"       JSON                         NOT NULL
postgres  | 	      );
postgres  | 	
postgres  | 	      -- add `license_creation_date` field for license_data table
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE license_data ADD COLUMN license_creation_date TIMESTAMP;
postgres  | 	        EXCEPTION WHEN duplicate_column THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      -- ca_certificates table
postgres  | 	      ALTER TABLE ca_certificates DROP CONSTRAINT IF EXISTS ca_certificates_cert_key;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE ca_certificates ADD COLUMN "cert_digest" TEXT UNIQUE;
postgres  | 	        EXCEPTION WHEN duplicate_column THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.789 UTC [93] LOG:  duration: 5.646 ms
postgres  | 2023-09-19 07:30:33.789 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['006_1301_to_1500'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '006_1301_to_1500');
postgres  | 2023-09-19 07:30:33.789 UTC [93] LOG:  duration: 0.155 ms
postgres  | 2023-09-19 07:30:33.789 UTC [93] LOG:  statement:         DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" ADD "run_on" TEXT;
postgres  | 	        EXCEPTION WHEN duplicate_column THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.790 UTC [93] LOG:  duration: 0.155 ms
postgres  | 2023-09-19 07:30:33.790 UTC [93] LOG:  statement:     DELETE FROM workspace_entities WHERE entity_id IN (
postgres  | 	      SELECT entity_id FROM (
postgres  | 	        SELECT * from workspace_entities WHERE entity_type='keyauth_credentials'
postgres  | 	      ) t1 LEFT JOIN keyauth_credentials t2
postgres  | 	      ON t2.id::text = t1.entity_id
postgres  | 	      WHERE t2.id IS NULL
postgres  | 	    );
postgres  | 	  
postgres  | 2023-09-19 07:30:33.790 UTC [93] LOG:  duration: 0.300 ms
postgres  | 2023-09-19 07:30:33.790 UTC [93] LOG:  statement:     UPDATE workspace_entity_counters AS wec
postgres  | 	      SET count = we.count FROM (
postgres  | 	        SELECT d.workspace_id AS workspace_id,
postgres  | 	               d.entity_type AS entity_type,
postgres  | 	               coalesce(c.count, 0) AS count
postgres  | 	        FROM (
postgres  | 	          SELECT id AS workspace_id, 'keyauth_credentials'::text AS entity_type
postgres  | 	          FROM workspaces
postgres  | 	        ) AS d LEFT JOIN (
postgres  | 	        SELECT workspace_id, entity_type, COUNT(DISTINCT entity_id)
postgres  | 	          FROM workspace_entities
postgres  | 	          WHERE entity_type = 'keyauth_credentials'
postgres  | 	          GROUP BY workspace_id, entity_type
postgres  | 	        ) c
postgres  | 	        ON d.workspace_id = c.workspace_id
postgres  | 	      ) AS we
postgres  | 	    WHERE wec.workspace_id = we.workspace_id
postgres  | 	    AND wec.entity_type = we.entity_type;
postgres  | 	  
postgres  | 2023-09-19 07:30:33.791 UTC [93] LOG:  duration: 0.314 ms
postgres  | 2023-09-19 07:30:33.791 UTC [93] LOG:  statement:     DELETE FROM workspace_entities WHERE entity_id IN (
postgres  | 	      SELECT entity_id FROM (
postgres  | 	        SELECT * from workspace_entities WHERE entity_type='oauth2_tokens'
postgres  | 	      ) t1 LEFT JOIN oauth2_tokens t2
postgres  | 	      ON t2.id::text = t1.entity_id
postgres  | 	      WHERE t2.id IS NULL
postgres  | 	    );
postgres  | 	  
postgres  | 2023-09-19 07:30:33.791 UTC [93] LOG:  duration: 0.234 ms
postgres  | 2023-09-19 07:30:33.791 UTC [93] LOG:  statement:     UPDATE workspace_entity_counters AS wec
postgres  | 	      SET count = we.count FROM (
postgres  | 	        SELECT d.workspace_id AS workspace_id,
postgres  | 	               d.entity_type AS entity_type,
postgres  | 	               coalesce(c.count, 0) AS count
postgres  | 	        FROM (
postgres  | 	          SELECT id AS workspace_id, 'oauth2_tokens'::text AS entity_type
postgres  | 	          FROM workspaces
postgres  | 	        ) AS d LEFT JOIN (
postgres  | 	        SELECT workspace_id, entity_type, COUNT(DISTINCT entity_id)
postgres  | 	          FROM workspace_entities
postgres  | 	          WHERE entity_type = 'oauth2_tokens'
postgres  | 	          GROUP BY workspace_id, entity_type
postgres  | 	        ) c
postgres  | 	        ON d.workspace_id = c.workspace_id
postgres  | 	      ) AS we
postgres  | 	    WHERE wec.workspace_id = we.workspace_id
postgres  | 	    AND wec.entity_type = we.entity_type;
postgres  | 	  
postgres  | 2023-09-19 07:30:33.791 UTC [93] LOG:  duration: 0.160 ms
postgres  | 2023-09-19 07:30:33.791 UTC [93] LOG:  statement:     DELETE FROM workspace_entities WHERE entity_id IN (
postgres  | 	      SELECT entity_id FROM (
postgres  | 	        SELECT * from workspace_entities WHERE entity_type='oauth2_authorization_codes'
postgres  | 	      ) t1 LEFT JOIN oauth2_authorization_codes t2
postgres  | 	      ON t2.id::text = t1.entity_id
postgres  | 	      WHERE t2.id IS NULL
postgres  | 	    );
postgres  | 	  
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  duration: 0.205 ms
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  statement:     UPDATE workspace_entity_counters AS wec
postgres  | 	      SET count = we.count FROM (
postgres  | 	        SELECT d.workspace_id AS workspace_id,
postgres  | 	               d.entity_type AS entity_type,
postgres  | 	               coalesce(c.count, 0) AS count
postgres  | 	        FROM (
postgres  | 	          SELECT id AS workspace_id, 'oauth2_authorization_codes'::text AS entity_type
postgres  | 	          FROM workspaces
postgres  | 	        ) AS d LEFT JOIN (
postgres  | 	        SELECT workspace_id, entity_type, COUNT(DISTINCT entity_id)
postgres  | 	          FROM workspace_entities
postgres  | 	          WHERE entity_type = 'oauth2_authorization_codes'
postgres  | 	          GROUP BY workspace_id, entity_type
postgres  | 	        ) c
postgres  | 	        ON d.workspace_id = c.workspace_id
postgres  | 	      ) AS we
postgres  | 	    WHERE wec.workspace_id = we.workspace_id
postgres  | 	    AND wec.entity_type = we.entity_type;
postgres  | 	  
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  duration: 0.153 ms
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  statement: SELECT * FROM ca_certificates
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  duration: 0.063 ms
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  statement: ALTER TABLE ca_certificates ALTER COLUMN cert_digest SET NOT NULL
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  duration: 0.108 ms
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '006_1301_to_1500', ARRAY['006_1301_to_1500'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '006_1301_to_1500'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '006_1301_to_1500');
postgres  | 2023-09-19 07:30:33.792 UTC [93] LOG:  duration: 0.144 ms
postgres  | 2023-09-19 07:30:33.793 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DROP TRIGGER IF EXISTS "delete_expired_cluster_events_trigger" ON "cluster_events";
postgres  | 	      DROP FUNCTION IF EXISTS "delete_expired_cluster_events" ();
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.793 UTC [93] LOG:  duration: 0.080 ms
postgres  | 2023-09-19 07:30:33.793 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '006_1301_to_1302', ARRAY['006_1301_to_1302'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '006_1301_to_1302');
postgres  | 2023-09-19 07:30:33.793 UTC [93] LOG:  duration: 0.135 ms
postgres  | 2023-09-19 07:30:33.793 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "ws_migrations_backup" (
postgres  | 	            "entity_type"               TEXT,
postgres  | 	            "entity_id"                 TEXT,
postgres  | 	            "unique_field_name"         TEXT,
postgres  | 	            "unique_field_value"        TEXT,
postgres  | 	            "created_at"                TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC')
postgres  | 	          );
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.794 UTC [93] LOG:  duration: 0.712 ms
postgres  | 2023-09-19 07:30:33.794 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['010_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '010_1500_to_2100');
postgres  | 2023-09-19 07:30:33.794 UTC [93] LOG:  duration: 0.128 ms
postgres  | 2023-09-19 07:30:33.794 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '010_1500_to_2100', ARRAY['010_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '010_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '010_1500_to_2100');
postgres  | 2023-09-19 07:30:33.794 UTC [93] LOG:  duration: 0.143 ms
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "audit_requests" ADD removed_from_payload TEXT;
postgres  | 	      EXCEPTION WHEN duplicate_column THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  duration: 0.175 ms
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['007_1500_to_1504'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '007_1500_to_1504');
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  duration: 0.123 ms
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '007_1500_to_1504', ARRAY['007_1500_to_1504'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '007_1500_to_1504'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '007_1500_to_1504');
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  duration: 0.129 ms
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- update all old records that doesn't have current timestamp for `license_creation_date` field after migrations
postgres  | 	      UPDATE license_data SET license_creation_date = CURRENT_TIMESTAMP WHERE license_creation_date IS NULL;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.795 UTC [93] LOG:  duration: 0.116 ms
postgres  | 2023-09-19 07:30:33.796 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['008_1504_to_1505'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '008_1504_to_1505');
postgres  | 2023-09-19 07:30:33.796 UTC [93] LOG:  duration: 0.126 ms
postgres  | 2023-09-19 07:30:33.796 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '008_1504_to_1505', ARRAY['008_1504_to_1505'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '008_1504_to_1505'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '008_1504_to_1505');
postgres  | 2023-09-19 07:30:33.796 UTC [93] LOG:  duration: 0.127 ms
postgres  | 2023-09-19 07:30:33.796 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "applications" ADD "custom_id" TEXT UNIQUE;
postgres  | 	      EXCEPTION WHEN duplicate_column THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	            -- Add ws_id to rbac_users, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "rbac_users" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_users" ADD CONSTRAINT "rbac_users_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'rbac_users.name' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_users" DROP CONSTRAINT IF EXISTS "rbac_users_name_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, name) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "rbac_users" ADD CONSTRAINT "rbac_users_ws_id_name_unique" UNIQUE ("ws_id", "name");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to rbac_roles, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "rbac_roles" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_roles" ADD CONSTRAINT "rbac_roles_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'rbac_roles.name' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_roles" DROP CONSTRAINT IF EXISTS "rbac_roles_name_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, name) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "rbac_roles" ADD CONSTRAINT "rbac_roles_ws_id_name_unique" UNIQUE ("ws_id", "name");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to files, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "files" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "files" ADD CONSTRAINT "files_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'files.path' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "files" DROP CONSTRAINT IF EXISTS "files_path_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, path) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "files" ADD CONSTRAINT "files_ws_id_path_unique" UNIQUE ("ws_id", "path");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to developers, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "developers" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "developers" ADD CONSTRAINT "developers_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "developers" DROP CONSTRAINT IF EXISTS "developers_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "developers"
postgres  | 	                        ADD CONSTRAINT "developers_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "developers" DROP CONSTRAINT IF EXISTS "developers_rbac_user_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "developers"
postgres  | 	                        ADD CONSTRAINT "developers_rbac_user_id_fkey"
postgres  | 	                           FOREIGN KEY ("rbac_user_id", "ws_id")
postgres  | 	                            REFERENCES rbac_users("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'developers.email' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "developers" DROP CONSTRAINT IF EXISTS "developers_email_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, email) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "developers" ADD CONSTRAINT "developers_ws_id_email_unique" UNIQUE ("ws_id", "email");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'developers.custom_id' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "developers" DROP CONSTRAINT IF EXISTS "developers_custom_id_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, custom_id) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "developers" ADD CONSTRAINT "developers_ws_id_custom_id_unique" UNIQUE ("ws_id", "custom_id");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to document_objects, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "document_objects" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "document_objects" ADD CONSTRAINT "document_objects_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "document_objects" DROP CONSTRAINT IF EXISTS "document_objects_service_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "document_objects"
postgres  | 	                        ADD CONSTRAINT "document_objects_service_id_fkey"
postgres  | 	                           FOREIGN KEY ("service_id", "ws_id")
postgres  | 	                            REFERENCES services("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'document_objects.path' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "document_objects" DROP CONSTRAINT IF EXISTS "document_objects_path_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, path) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "document_objects" ADD CONSTRAINT "document_objects_ws_id_path_unique" UNIQUE ("ws_id", "path");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to applications, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "applications" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "applications" ADD CONSTRAINT "applications_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "applications" DROP CONSTRAINT IF EXISTS "applications_consumer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "applications"
postgres  | 	                        ADD CONSTRAINT "applications_consumer_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_id", "ws_id")
postgres  | 	                            REFERENCES consumers("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "applications" DROP CONSTRAINT IF EXISTS "applications_developer_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "applications"
postgres  | 	                        ADD CONSTRAINT "applications_developer_id_fkey"
postgres  | 	                           FOREIGN KEY ("developer_id", "ws_id")
postgres  | 	                            REFERENCES developers("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to application_instances, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "application_instances" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "application_instances" ADD CONSTRAINT "application_instances_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "application_instances" DROP CONSTRAINT IF EXISTS "application_instances_application_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "application_instances"
postgres  | 	                        ADD CONSTRAINT "application_instances_application_id_fkey"
postgres  | 	                           FOREIGN KEY ("application_id", "ws_id")
postgres  | 	                            REFERENCES applications("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "application_instances" DROP CONSTRAINT IF EXISTS "application_instances_service_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "application_instances"
postgres  | 	                        ADD CONSTRAINT "application_instances_service_id_fkey"
postgres  | 	                           FOREIGN KEY ("service_id", "ws_id")
postgres  | 	                            REFERENCES services("id", "ws_id") ;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'application_instances.composite_id' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "application_instances" DROP CONSTRAINT IF EXISTS "application_instances_composite_id_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, composite_id) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "application_instances" ADD CONSTRAINT "application_instances_ws_id_composite_id_unique" UNIQUE ("ws_id", "composite_id");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.809 UTC [93] LOG:  duration: 12.737 ms
postgres  | 2023-09-19 07:30:33.809 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['007_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '007_1500_to_2100');
postgres  | 2023-09-19 07:30:33.809 UTC [93] LOG:  duration: 0.173 ms
postgres  | 2023-09-19 07:30:33.810 UTC [93] LOG:  statement:         DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" DROP COLUMN "run_on";
postgres  | 	        EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.810 UTC [93] LOG:  duration: 0.152 ms
postgres  | 2023-09-19 07:30:33.810 UTC [93] LOG:  statement:         SELECT * FROM pg_catalog.pg_tables WHERE tablename='workspace_entities';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.810 UTC [93] LOG:  duration: 0.295 ms
postgres  | 2023-09-19 07:30:33.811 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.811 UTC [93] LOG:  duration: 0.564 ms
postgres  | 2023-09-19 07:30:33.816 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for upstreams
postgres  | 	
postgres  | 	      UPDATE upstreams
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='upstreams'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=upstreams.id::text;
postgres  | 	            UPDATE upstreams SET name = regexp_replace(name, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.816 UTC [93] LOG:  duration: 0.306 ms
postgres  | 2023-09-19 07:30:33.816 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.817 UTC [93] LOG:  duration: 0.363 ms
postgres  | 2023-09-19 07:30:33.817 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for targets
postgres  | 	
postgres  | 	      UPDATE targets
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='targets'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=targets.id::text;
postgres  | 	    ;COMMIT
postgres  | 2023-09-19 07:30:33.817 UTC [93] LOG:  duration: 0.144 ms
postgres  | 2023-09-19 07:30:33.817 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.817 UTC [93] LOG:  duration: 0.353 ms
postgres  | 2023-09-19 07:30:33.818 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for consumers
postgres  | 	
postgres  | 	      UPDATE consumers
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='consumers'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=consumers.id::text;
postgres  | 	            UPDATE consumers SET username = regexp_replace(username, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', ''), custom_id = regexp_replace(custom_id, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.818 UTC [93] LOG:  duration: 0.197 ms
postgres  | 2023-09-19 07:30:33.818 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.818 UTC [93] LOG:  duration: 0.354 ms
postgres  | 2023-09-19 07:30:33.819 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for certificates
postgres  | 	
postgres  | 	      UPDATE certificates
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='certificates'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=certificates.id::text;
postgres  | 	    ;COMMIT
postgres  | 2023-09-19 07:30:33.819 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.819 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.819 UTC [93] LOG:  duration: 0.355 ms
postgres  | 2023-09-19 07:30:33.819 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for snis
postgres  | 	
postgres  | 	      UPDATE snis
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='snis'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=snis.id::text;
postgres  | 	    ;COMMIT
postgres  | 2023-09-19 07:30:33.819 UTC [93] LOG:  duration: 0.149 ms
postgres  | 2023-09-19 07:30:33.820 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.820 UTC [93] LOG:  duration: 0.343 ms
postgres  | 2023-09-19 07:30:33.820 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for services
postgres  | 	
postgres  | 	      UPDATE services
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='services'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=services.id::text;
postgres  | 	            UPDATE services SET name = regexp_replace(name, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.820 UTC [93] LOG:  duration: 0.184 ms
postgres  | 2023-09-19 07:30:33.820 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.821 UTC [93] LOG:  duration: 0.349 ms
postgres  | 2023-09-19 07:30:33.821 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for routes
postgres  | 	
postgres  | 	      UPDATE routes
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='routes'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=routes.id::text;
postgres  | 	            UPDATE routes SET name = regexp_replace(name, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.821 UTC [93] LOG:  duration: 0.194 ms
postgres  | 2023-09-19 07:30:33.821 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.822 UTC [93] LOG:  duration: 0.341 ms
postgres  | 2023-09-19 07:30:33.822 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for plugins
postgres  | 	
postgres  | 	      UPDATE plugins
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='plugins'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=plugins.id::text;
postgres  | 	    ;COMMIT
postgres  | 2023-09-19 07:30:33.822 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.822 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.823 UTC [93] LOG:  duration: 0.346 ms
postgres  | 2023-09-19 07:30:33.823 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for rbac_users
postgres  | 	
postgres  | 	      UPDATE rbac_users
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='rbac_users'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=rbac_users.id::text;
postgres  | 	            UPDATE rbac_users SET name = regexp_replace(name, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.823 UTC [93] LOG:  duration: 0.206 ms
postgres  | 2023-09-19 07:30:33.823 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.823 UTC [93] LOG:  duration: 0.338 ms
postgres  | 2023-09-19 07:30:33.824 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for rbac_roles
postgres  | 	
postgres  | 	      UPDATE rbac_roles
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='rbac_roles'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=rbac_roles.id::text;
postgres  | 	            UPDATE rbac_roles SET name = regexp_replace(name, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.824 UTC [93] LOG:  duration: 0.441 ms
postgres  | 2023-09-19 07:30:33.824 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.825 UTC [93] LOG:  duration: 0.353 ms
postgres  | 2023-09-19 07:30:33.825 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for files
postgres  | 	
postgres  | 	      UPDATE files
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='files'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=files.id::text;
postgres  | 	            UPDATE files SET path = regexp_replace(path, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.825 UTC [93] LOG:  duration: 0.216 ms
postgres  | 2023-09-19 07:30:33.825 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.826 UTC [93] LOG:  duration: 0.363 ms
postgres  | 2023-09-19 07:30:33.826 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for developers
postgres  | 	
postgres  | 	      UPDATE developers
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='developers'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=developers.id::text;
postgres  | 	            UPDATE developers SET email = regexp_replace(email, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', ''), custom_id = regexp_replace(custom_id, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.826 UTC [93] LOG:  duration: 0.217 ms
postgres  | 2023-09-19 07:30:33.826 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.827 UTC [93] LOG:  duration: 0.347 ms
postgres  | 2023-09-19 07:30:33.827 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for document_objects
postgres  | 	
postgres  | 	      UPDATE document_objects
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='document_objects'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=document_objects.id::text;
postgres  | 	            UPDATE document_objects SET path = regexp_replace(path, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.827 UTC [93] LOG:  duration: 0.194 ms
postgres  | 2023-09-19 07:30:33.827 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.827 UTC [93] LOG:  duration: 0.336 ms
postgres  | 2023-09-19 07:30:33.828 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for applications
postgres  | 	
postgres  | 	      UPDATE applications
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='applications'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=applications.id::text;
postgres  | 	    ;COMMIT
postgres  | 2023-09-19 07:30:33.828 UTC [93] LOG:  duration: 0.153 ms
postgres  | 2023-09-19 07:30:33.828 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.828 UTC [93] LOG:  duration: 0.331 ms
postgres  | 2023-09-19 07:30:33.828 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for application_instances
postgres  | 	
postgres  | 	      UPDATE application_instances
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='application_instances'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=application_instances.id::text;
postgres  | 	            UPDATE application_instances SET composite_id = regexp_replace(composite_id, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.829 UTC [93] LOG:  duration: 0.200 ms
postgres  | 2023-09-19 07:30:33.829 UTC [93] LOG:  statement:         UPDATE rbac_users
postgres  | 	           SET name = 'kong_admin'
postgres  | 	         WHERE name = 'default:kong_admin';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.829 UTC [93] LOG:  duration: 0.070 ms
postgres  | 2023-09-19 07:30:33.829 UTC [93] LOG:  statement: BEGIN;
postgres  | 	            -- assign admin linked rbac_users' ws_id to default ws id
postgres  | 	
postgres  | 	            update rbac_users
postgres  | 	            set ws_id = (select id from workspaces where name='default')
postgres  | 	            where id in (select rbac_user_id from admins);
postgres  | 	          ;COMMIT
postgres  | 2023-09-19 07:30:33.829 UTC [93] LOG:  duration: 0.197 ms
postgres  | 2023-09-19 07:30:33.829 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '007_1500_to_2100', ARRAY['007_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '007_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '007_1500_to_2100');
postgres  | 2023-09-19 07:30:33.830 UTC [93] LOG:  duration: 0.148 ms
postgres  | 2023-09-19 07:30:33.830 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE INDEX IF NOT EXISTS login_attempts_ttl_idx ON login_attempts (ttl);
postgres  | 	      CREATE INDEX IF NOT EXISTS audit_requests_ttl_idx ON audit_requests (ttl);
postgres  | 	      CREATE INDEX IF NOT EXISTS audit_objects_ttl_idx ON audit_objects (ttl);
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.831 UTC [93] LOG:  duration: 1.387 ms
postgres  | 2023-09-19 07:30:33.831 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['009_1506_to_1507'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '009_1506_to_1507');
postgres  | 2023-09-19 07:30:33.831 UTC [93] LOG:  duration: 0.129 ms
postgres  | 2023-09-19 07:30:33.831 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '009_1506_to_1507', ARRAY['009_1506_to_1507'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '009_1506_to_1507'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '009_1506_to_1507');
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  duration: 0.131 ms
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['009_2100_to_2200'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '009_2100_to_2200');
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  duration: 0.125 ms
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  statement:         SELECT * FROM pg_catalog.pg_tables WHERE tablename='workspace_entities';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  duration: 0.142 ms
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  statement: 
postgres  | 	        -- revert consumers ws_id from workspace_entities table
postgres  | 	
postgres  | 	        UPDATE consumers
postgres  | 	        SET ws_id = we.workspace_id
postgres  | 	        FROM workspace_entities we
postgres  | 	        WHERE entity_type='consumers'
postgres  | 	          AND unique_field_name='id'
postgres  | 	          AND unique_field_value=consumers.id::text;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  duration: 0.090 ms
postgres  | 2023-09-19 07:30:33.832 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '009_2100_to_2200', ARRAY['009_2100_to_2200'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '009_2100_to_2200'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '009_2100_to_2200');
postgres  | 2023-09-19 07:30:33.833 UTC [93] LOG:  duration: 0.139 ms
postgres  | 2023-09-19 07:30:33.833 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- new vitals tables
postgres  | 	      CREATE TABLE IF NOT EXISTS vitals_stats_days (LIKE vitals_stats_minutes INCLUDING defaults INCLUDING constraints INCLUDING indexes);
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.834 UTC [93] LOG:  duration: 0.904 ms
postgres  | 2023-09-19 07:30:33.834 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['010_2200_to_2211'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '010_2200_to_2211');
postgres  | 2023-09-19 07:30:33.834 UTC [93] LOG:  duration: 0.140 ms
postgres  | 2023-09-19 07:30:33.834 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '010_2200_to_2211', ARRAY['010_2200_to_2211'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '010_2200_to_2211'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '010_2200_to_2211');
postgres  | 2023-09-19 07:30:33.834 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.834 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS licenses(
postgres  | 	              id                uuid PRIMARY KEY,
postgres  | 	              payload text,
postgres  | 	              created_at        timestamp without time zone DEFAULT timezone('utc'::text, ('now'::text)::timestamp(0) with time zone),
postgres  | 	              updated_at        timestamp without time zone DEFAULT timezone('utc'::text, ('now'::text)::timestamp(0) with time zone)
postgres  | 	        );
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.836 UTC [93] LOG:  duration: 1.102 ms
postgres  | 2023-09-19 07:30:33.836 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '010_2200_to_2300', ARRAY['010_2200_to_2300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '010_2200_to_2300');
postgres  | 2023-09-19 07:30:33.836 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.836 UTC [93] LOG:  statement: BEGIN;
postgres  | 	ALTER TABLE IF EXISTS ONLY "licenses" ALTER COLUMN "created_at" DROP DEFAULT;
postgres  | 	      ALTER TABLE IF EXISTS ONLY "licenses" ALTER COLUMN "created_at" TYPE TIMESTAMP WITH TIME ZONE USING "created_at" AT TIME ZONE 'UTC';
postgres  | 	
postgres  | 	      ALTER TABLE IF EXISTS ONLY "licenses" ALTER COLUMN "updated_at" DROP DEFAULT;
postgres  | 	      ALTER TABLE IF EXISTS ONLY "licenses" ALTER COLUMN "updated_at" TYPE TIMESTAMP WITH TIME ZONE USING "updated_at" AT TIME ZONE 'UTC';
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.839 UTC [93] LOG:  duration: 2.733 ms
postgres  | 2023-09-19 07:30:33.839 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['010_2200_to_2300_1'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '010_2200_to_2300_1');
postgres  | 2023-09-19 07:30:33.839 UTC [93] LOG:  duration: 0.152 ms
postgres  | 2023-09-19 07:30:33.839 UTC [93] LOG:  statement:         DELETE FROM licenses WHERE payload IS NULL;
postgres  | 	        ALTER TABLE IF EXISTS ONLY "licenses" ALTER COLUMN "payload" SET NOT NULL;
postgres  | 	
postgres  | 	        DELETE FROM licenses WHERE id IN (
postgres  | 	          SELECT l.id FROM licenses l, licenses ll
postgres  | 	          WHERE l.payload = ll.payload
postgres  | 	          AND l.id < ll.id
postgres  | 	        );
postgres  | 	
postgres  | 	        ALTER TABLE "licenses" DROP CONSTRAINT IF EXISTS "licenses_payload_key";
postgres  | 	        ALTER TABLE IF EXISTS ONLY "licenses" ADD CONSTRAINT "licenses_payload_key" UNIQUE (payload);
postgres  | 	      
postgres  | 2023-09-19 07:30:33.840 UTC [93] LOG:  duration: 0.759 ms
postgres  | 2023-09-19 07:30:33.840 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '010_2200_to_2300_1', ARRAY['010_2200_to_2300_1'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '010_2200_to_2300_1'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '010_2200_to_2300_1');
postgres  | 2023-09-19 07:30:33.840 UTC [93] LOG:  duration: 0.144 ms
postgres  | 2023-09-19 07:30:33.840 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "admins" ADD "username_lower" TEXT;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      UPDATE admins SET username_lower=LOWER(username);
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.840 UTC [93] LOG:  duration: 0.232 ms
postgres  | 2023-09-19 07:30:33.841 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['011_2300_to_2600'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '011_2300_to_2600');
postgres  | 2023-09-19 07:30:33.841 UTC [93] LOG:  duration: 0.134 ms
postgres  | 2023-09-19 07:30:33.841 UTC [93] LOG:  statement: SELECT id, ws_id, username, username_lower, type, created_at FROM consumers
postgres  | 2023-09-19 07:30:33.841 UTC [93] LOG:  duration: 0.063 ms
postgres  | 2023-09-19 07:30:33.841 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '011_2300_to_2600', ARRAY['011_2300_to_2600'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '011_2300_to_2600'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '011_2300_to_2600');
postgres  | 2023-09-19 07:30:33.841 UTC [93] LOG:  duration: 0.135 ms
postgres  | 2023-09-19 07:30:33.841 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	      BEGIN
postgres  | 	      UPDATE consumers
postgres  | 	      SET
postgres  | 	        username = CONCAT(username, '_ADMIN_'),
postgres  | 	        username_lower = CONCAT(username_lower, '_admin_')
postgres  | 	      WHERE
postgres  | 	        username !~ '_ADMIN_$'
postgres  | 	      AND
postgres  | 	        type = 2;
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "license_data" ADD "year" smallint;
postgres  | 	        ALTER TABLE IF EXISTS ONLY "license_data" ADD "month" smallint;
postgres  | 	      EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        UPDATE "license_data" SET "year" = 0 WHERE "year" IS NULL;
postgres  | 	        UPDATE "license_data" SET "month" = 0 WHERE "month" IS NULL;
postgres  | 	        ALTER TABLE "license_data" ALTER COLUMN "year" SET NOT NULL;
postgres  | 	        ALTER TABLE "license_data" ALTER COLUMN "month" SET NOT NULL;
postgres  | 	        DROP INDEX IF EXISTS license_data_key_idx;
postgres  | 	        ALTER TABLE license_data DROP CONSTRAINT IF EXISTS license_data_pkey;
postgres  | 	        CREATE UNIQUE INDEX IF NOT EXISTS license_data_key_idx ON license_data(node_id, year, month);
postgres  | 	      END
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.842 UTC [93] LOG:  duration: 0.983 ms
postgres  | 2023-09-19 07:30:33.842 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '012_2600_to_2700', ARRAY['012_2600_to_2700'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '012_2600_to_2700');
postgres  | 2023-09-19 07:30:33.843 UTC [93] LOG:  duration: 0.135 ms
postgres  | 2023-09-19 07:30:33.843 UTC [93] LOG:  statement: BEGIN;
postgres  | 	CREATE TABLE IF NOT EXISTS "consumer_groups" (
postgres  | 	        "id"          UUID                         PRIMARY KEY,
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "name"        TEXT                         UNIQUE
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "consumer_groups_name_idx" ON "consumer_groups" ("name");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "consumer_group_plugins" (
postgres  | 	        "id"          UUID                         PRIMARY KEY,
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "consumer_group_id"     UUID                         REFERENCES "consumer_groups" ("id") ON DELETE CASCADE,
postgres  | 	        "name"        TEXT                         NOT NULL,
postgres  | 	        "cache_key"   TEXT                         UNIQUE,
postgres  | 	        "config"      JSONB                        NOT NULL
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "consumer_group_plugins_group_id_idx" ON "consumer_group_plugins" ("consumer_group_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "consumer_group_plugins_plugin_name_idx" ON "consumer_group_plugins" ("name");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      CREATE TABLE IF NOT EXISTS "consumer_group_consumers" (
postgres  | 	        "created_at"  TIMESTAMP WITH TIME ZONE     DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC'),
postgres  | 	        "consumer_group_id"     UUID                         REFERENCES "consumer_groups" ("id") ON DELETE CASCADE,
postgres  | 	        "consumer_id" UUID                         REFERENCES "consumers" ("id") ON DELETE CASCADE,
postgres  | 	        "cache_key"   TEXT                         UNIQUE,
postgres  | 	        PRIMARY KEY (consumer_group_id, consumer_id)
postgres  | 	      );
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "consumer_group_consumers_group_id_idx" ON "consumer_group_consumers" ("consumer_group_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS "consumer_group_consumers_consumer_id_idx" ON "consumer_group_consumers" ("consumer_id");
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	
postgres  | 	              -- Add ws_id to consumer_groups, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "consumer_groups" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_groups" ADD CONSTRAINT "consumer_groups_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Make 'consumer_groups.name' unique per workspace
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_groups" DROP CONSTRAINT IF EXISTS "consumer_groups_name_key";
postgres  | 	
postgres  | 	          -- Ensure (ws_id, name) pair is unique
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "consumer_groups" ADD CONSTRAINT "consumer_groups_ws_id_name_unique" UNIQUE ("ws_id", "name");
postgres  | 	          EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	
postgres  | 	      
postgres  | 	        -- Add ws_id to consumer_group_plugins, populating all of them with the default workspace id
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          EXECUTE format('ALTER TABLE IF EXISTS ONLY "consumer_group_plugins" ADD "ws_id" UUID REFERENCES "workspaces" ("id") DEFAULT %L',
postgres  | 	                        (SELECT "id" FROM "workspaces" WHERE "name" = 'default'));
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	        -- Ensure (id, ws_id) pair is unique
postgres  | 	        DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_group_plugins" ADD CONSTRAINT "consumer_group_plugins_id_ws_id_unique" UNIQUE ("id", "ws_id");
postgres  | 	        EXCEPTION WHEN DUPLICATE_TABLE THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END$$;
postgres  | 	
postgres  | 	      
postgres  | 	
postgres  | 	          -- Update foreign key relationship
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_group_plugins" DROP CONSTRAINT IF EXISTS "consumer_group_plugins_consumer_group_id_fkey";
postgres  | 	
postgres  | 	          DO $$
postgres  | 	          BEGIN
postgres  | 	            ALTER TABLE IF EXISTS ONLY "consumer_group_plugins"
postgres  | 	                        ADD CONSTRAINT "consumer_group_plugins_consumer_group_id_fkey"
postgres  | 	                           FOREIGN KEY ("consumer_group_id", "ws_id")
postgres  | 	                            REFERENCES consumer_groups("id", "ws_id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_OBJECT THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.852 UTC [93] LOG:  duration: 9.544 ms
postgres  | 2023-09-19 07:30:33.853 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['012_2600_to_2700_1'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '012_2600_to_2700_1');
postgres  | 2023-09-19 07:30:33.853 UTC [93] LOG:  duration: 0.186 ms
postgres  | 2023-09-19 07:30:33.853 UTC [93] LOG:  statement:         DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" DROP COLUMN "run_on";
postgres  | 	        EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.853 UTC [93] LOG:  duration: 0.126 ms
postgres  | 2023-09-19 07:30:33.853 UTC [93] LOG:  statement:         SELECT * FROM pg_catalog.pg_tables WHERE tablename='workspace_entities';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.853 UTC [93] LOG:  duration: 0.162 ms
postgres  | 2023-09-19 07:30:33.853 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.854 UTC [93] LOG:  duration: 0.409 ms
postgres  | 2023-09-19 07:30:33.854 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for consumer_groups
postgres  | 	
postgres  | 	      UPDATE consumer_groups
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='consumer_groups'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=consumer_groups.id::text;
postgres  | 	            UPDATE consumer_groups SET name = regexp_replace(name, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.854 UTC [93] LOG:  duration: 0.238 ms
postgres  | 2023-09-19 07:30:33.854 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.855 UTC [93] LOG:  duration: 0.367 ms
postgres  | 2023-09-19 07:30:33.855 UTC [93] LOG:  statement: BEGIN;
postgres  | 	      -- fixing up workspaceable rows for consumer_group_plugins
postgres  | 	
postgres  | 	      UPDATE consumer_group_plugins
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='consumer_group_plugins'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=consumer_group_plugins.id::text;
postgres  | 	    ;COMMIT
postgres  | 2023-09-19 07:30:33.855 UTC [93] LOG:  duration: 0.156 ms
postgres  | 2023-09-19 07:30:33.855 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '012_2600_to_2700_1', ARRAY['012_2600_to_2700_1'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '012_2600_to_2700_1'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '012_2600_to_2700_1');
postgres  | 2023-09-19 07:30:33.855 UTC [93] LOG:  duration: 0.131 ms
postgres  | 2023-09-19 07:30:33.855 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['013_2700_to_2800'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '013_2700_to_2800');
postgres  | 2023-09-19 07:30:33.856 UTC [93] LOG:  duration: 0.122 ms
postgres  | 2023-09-19 07:30:33.856 UTC [93] LOG:  statement:         DELETE FROM workspace_entity_counters
postgres  | 	              WHERE entity_type = 'oauth2_tokens';
postgres  | 	      
postgres  | 2023-09-19 07:30:33.856 UTC [93] LOG:  duration: 0.063 ms
postgres  | 2023-09-19 07:30:33.856 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '013_2700_to_2800', ARRAY['013_2700_to_2800'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '013_2700_to_2800'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '013_2700_to_2800');
postgres  | 2023-09-19 07:30:33.856 UTC [93] LOG:  duration: 0.315 ms
postgres  | 2023-09-19 07:30:33.856 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	        BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" ADD "ordering" jsonb;
postgres  | 	        EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	        $$;
postgres  | 	
postgres  | 	        CREATE TABLE IF NOT EXISTS keyring_keys (
postgres  | 	            id text PRIMARY KEY,
postgres  | 	            recovery_key_id text not null,
postgres  | 	            key_encrypted text not null,
postgres  | 	            created_at timestamp with time zone not null,
postgres  | 	            updated_at timestamp with time zone not null
postgres  | 	        );
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  duration: 1.120 ms
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise', ARRAY['014_2800_to_3000'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '014_2800_to_3000');
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  duration: 0.135 ms
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  statement: DELETE FROM plugins WHERE name = 'collector'
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  duration: 0.110 ms
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '014_2800_to_3000', ARRAY['014_2800_to_3000'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '014_2800_to_3000'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '014_2800_to_3000');
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  duration: 0.142 ms
postgres  | 2023-09-19 07:30:33.858 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- add tags to consumer_groups
postgres  | 	      DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_groups" ADD tags TEXT[];
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE INDEX IF NOT EXISTS consumer_groups_tags_idx ON consumer_groups USING GIN(tags);
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	      DROP TRIGGER IF EXISTS consumer_groups_sync_tags_trigger ON consumer_groups;
postgres  | 	      DO $$
postgres  | 	      BEGIN
postgres  | 	        CREATE TRIGGER consumer_groups_sync_tags_trigger
postgres  | 	        AFTER INSERT OR UPDATE OF tags OR DELETE ON consumer_groups
postgres  | 	        FOR EACH ROW
postgres  | 	        EXECUTE PROCEDURE sync_tags();
postgres  | 	      EXCEPTION WHEN UNDEFINED_COLUMN OR UNDEFINED_TABLE THEN
postgres  | 	        -- Do nothing, accept existing state
postgres  | 	      END$$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.859 UTC [93] LOG:  duration: 0.391 ms
postgres  | 2023-09-19 07:30:33.859 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '015_3000_to_3100', ARRAY['015_3000_to_3100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '015_3000_to_3100');
postgres  | 2023-09-19 07:30:33.859 UTC [93] LOG:  duration: 0.139 ms
postgres  | 2023-09-19 07:30:33.859 UTC [93] LOG:  statement: BEGIN;
postgres  | 	-- add rbac_user_name,request_source to audit_requests
postgres  | 	      DO $$
postgres  | 	        BEGIN
postgres  | 	        ALTER TABLE IF EXISTS ONLY "audit_requests" ADD COLUMN "rbac_user_name" TEXT;
postgres  | 	        ALTER TABLE IF EXISTS ONLY "audit_requests" ADD COLUMN "request_source" TEXT;
postgres  | 	        EXCEPTION WHEN duplicate_column THEN
postgres  | 	          -- Do nothing, accept existing state
postgres  | 	        END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.859 UTC [93] LOG:  duration: 0.199 ms
postgres  | 2023-09-19 07:30:33.859 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '016_3100_to_3200', ARRAY['016_3100_to_3200'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '016_3100_to_3200');
postgres  | 2023-09-19 07:30:33.860 UTC [93] LOG:  duration: 0.141 ms
postgres  | 2023-09-19 07:30:33.860 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_group_consumers" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_group_plugins" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "consumer_groups" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "credentials" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "event_hooks" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "files" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "group_rbac_roles" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "groups" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "keyring_meta" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "legacy_files" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "login_attempts" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "parameters" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_role_endpoints" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_role_entities" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_roles" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          ALTER TABLE IF EXISTS ONLY "rbac_users" ADD "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (CURRENT_TIMESTAMP(0) AT TIME ZONE 'UTC');
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.861 UTC [93] LOG:  duration: 1.191 ms
postgres  | 2023-09-19 07:30:33.861 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '017_3200_to_3300', ARRAY['017_3200_to_3300'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '017_3200_to_3300');
postgres  | 2023-09-19 07:30:33.861 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.861 UTC [93] LOG:  statement: BEGIN;
postgres  | 	DO $$
postgres  | 	          BEGIN
postgres  | 	          ALTER TABLE IF EXISTS ONLY "plugins" ADD COLUMN "consumer_group_id" UUID REFERENCES "consumer_groups" ("id") ON DELETE CASCADE;
postgres  | 	          EXCEPTION WHEN DUPLICATE_COLUMN THEN
postgres  | 	            -- Do nothing, accept existing state
postgres  | 	          END;
postgres  | 	      $$;
postgres  | 	
postgres  | 	      DO $$
postgres  | 	          DECLARE
postgres  | 	            tablename TEXT;
postgres  | 	          BEGIN
postgres  | 	          FOR tablename IN (
postgres  | 	            SELECT c.table_name
postgres  | 	            FROM information_schema.columns c
postgres  | 	            WHERE column_name = 'ws_id' and table_name in ('upstreams','targets','consumers','certificates','snis','services','routes','plugins','sm_vaults','key_sets','keys','acls','basicauth_credentials','hmacauth_credentials','jwt_secrets','keyauth_credentials','oauth2_credentials','oauth2_authorization_codes','oauth2_tokens','rbac_users','rbac_roles','files','developers','document_objects','applications','application_instances','consumer_groups','consumer_group_plugins')
postgres  | 	          )
postgres  | 	          LOOP
postgres  | 	            EXECUTE format('ALTER TABLE IF EXISTS ONLY "%I" DROP CONSTRAINT IF EXISTS "%I_ws_id_fkey"', tablename, tablename);
postgres  | 	            EXECUTE format('ALTER TABLE IF EXISTS ONLY "%I" ADD CONSTRAINT "%I_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "workspaces" ("id") ON DELETE CASCADE ON UPDATE NO ACTION', tablename, tablename);
postgres  | 	          END LOOP;
postgres  | 	      END
postgres  | 	      $$;
postgres  | 	COMMIT;
postgres  | 	
postgres  | 2023-09-19 07:30:33.872 UTC [93] LOG:  duration: 11.034 ms
postgres  | 2023-09-19 07:30:33.873 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise', '018_3300_to_3400', ARRAY['018_3300_to_3400'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '018_3300_to_3400');
postgres  | 2023-09-19 07:30:33.873 UTC [93] LOG:  duration: 0.235 ms
postgres  | 2023-09-19 07:30:33.873 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise.acl', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.873 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.873 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.874 UTC [93] LOG:  duration: 0.405 ms
postgres  | 2023-09-19 07:30:33.874 UTC [93] LOG:  statement: BEGIN;            UPDATE acls
postgres  | 	            SET ws_id = c.ws_id
postgres  | 	            FROM consumers c
postgres  | 	            WHERE acls.consumer_id = c.id;
postgres  | 	          ;COMMIT
postgres  | 2023-09-19 07:30:33.874 UTC [93] LOG:  duration: 0.182 ms
postgres  | 2023-09-19 07:30:33.874 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise.acl', '001_1500_to_2100', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.874 UTC [93] LOG:  duration: 0.154 ms
postgres  | 2023-09-19 07:30:33.875 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise.basic-auth', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.875 UTC [93] LOG:  duration: 0.137 ms
postgres  | 2023-09-19 07:30:33.875 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.875 UTC [93] LOG:  duration: 0.384 ms
postgres  | 2023-09-19 07:30:33.876 UTC [93] LOG:  statement: BEGIN;              INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'basicauth_credentials', basicauth_credentials.id::text, 'username', basicauth_credentials.username
postgres  | 	              FROM basicauth_credentials;
postgres  | 	                        UPDATE basicauth_credentials
postgres  | 	            SET ws_id = c.ws_id
postgres  | 	            FROM consumers c
postgres  | 	            WHERE basicauth_credentials.consumer_id = c.id;
postgres  | 	                  UPDATE basicauth_credentials SET username = regexp_replace(username, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.876 UTC [93] LOG:  duration: 0.285 ms
postgres  | 2023-09-19 07:30:33.876 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise.basic-auth', '001_1500_to_2100', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.876 UTC [93] LOG:  duration: 0.158 ms
postgres  | 2023-09-19 07:30:33.876 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise.hmac-auth', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.876 UTC [93] LOG:  duration: 0.176 ms
postgres  | 2023-09-19 07:30:33.877 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.877 UTC [93] LOG:  duration: 0.371 ms
postgres  | 2023-09-19 07:30:33.877 UTC [93] LOG:  statement: BEGIN;              INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'hmacauth_credentials', hmacauth_credentials.id::text, 'username', hmacauth_credentials.username
postgres  | 	              FROM hmacauth_credentials;
postgres  | 	                        UPDATE hmacauth_credentials
postgres  | 	            SET ws_id = c.ws_id
postgres  | 	            FROM consumers c
postgres  | 	            WHERE hmacauth_credentials.consumer_id = c.id;
postgres  | 	                  UPDATE hmacauth_credentials SET username = regexp_replace(username, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.877 UTC [93] LOG:  duration: 0.223 ms
postgres  | 2023-09-19 07:30:33.878 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise.hmac-auth', '001_1500_to_2100', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.878 UTC [93] LOG:  duration: 0.158 ms
postgres  | 2023-09-19 07:30:33.878 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise.jwt', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.878 UTC [93] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:33.878 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.879 UTC [93] LOG:  duration: 0.366 ms
postgres  | 2023-09-19 07:30:33.879 UTC [93] LOG:  statement: BEGIN;              INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'jwt_secrets', jwt_secrets.id::text, 'key', jwt_secrets.key
postgres  | 	              FROM jwt_secrets;
postgres  | 	                        UPDATE jwt_secrets
postgres  | 	            SET ws_id = c.ws_id
postgres  | 	            FROM consumers c
postgres  | 	            WHERE jwt_secrets.consumer_id = c.id;
postgres  | 	                  UPDATE jwt_secrets SET key = regexp_replace(key, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.879 UTC [93] LOG:  duration: 0.221 ms
postgres  | 2023-09-19 07:30:33.879 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise.jwt', '001_1500_to_2100', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.879 UTC [93] LOG:  duration: 0.156 ms
postgres  | 2023-09-19 07:30:33.880 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise.key-auth', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.880 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.880 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.880 UTC [93] LOG:  duration: 0.370 ms
postgres  | 2023-09-19 07:30:33.881 UTC [93] LOG:  statement: BEGIN;              INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'keyauth_credentials', keyauth_credentials.id::text, 'key', keyauth_credentials.key
postgres  | 	              FROM keyauth_credentials;
postgres  | 	                        UPDATE keyauth_credentials
postgres  | 	            SET ws_id = c.ws_id
postgres  | 	            FROM consumers c
postgres  | 	            WHERE keyauth_credentials.consumer_id = c.id;
postgres  | 	                  UPDATE keyauth_credentials SET key = regexp_replace(key, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.881 UTC [93] LOG:  duration: 0.229 ms
postgres  | 2023-09-19 07:30:33.881 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise.key-auth', '001_1500_to_2100', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.881 UTC [93] LOG:  duration: 0.175 ms
postgres  | 2023-09-19 07:30:33.881 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise.oauth2', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.881 UTC [93] LOG:  duration: 0.137 ms
postgres  | 2023-09-19 07:30:33.882 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.882 UTC [93] LOG:  duration: 0.362 ms
postgres  | 2023-09-19 07:30:33.882 UTC [93] LOG:  statement: BEGIN;              INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'oauth2_credentials', oauth2_credentials.id::text, 'client_id', oauth2_credentials.client_id
postgres  | 	              FROM oauth2_credentials;
postgres  | 	                        UPDATE oauth2_credentials
postgres  | 	            SET ws_id = c.ws_id
postgres  | 	            FROM consumers c
postgres  | 	            WHERE oauth2_credentials.consumer_id = c.id;
postgres  | 	                  UPDATE oauth2_credentials SET client_id = regexp_replace(client_id, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.882 UTC [93] LOG:  duration: 0.227 ms
postgres  | 2023-09-19 07:30:33.882 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.883 UTC [93] LOG:  duration: 0.346 ms
postgres  | 2023-09-19 07:30:33.883 UTC [93] LOG:  statement: BEGIN;              INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'oauth2_authorization_codes', oauth2_authorization_codes.id::text, 'code', oauth2_authorization_codes.code
postgres  | 	              FROM oauth2_authorization_codes;
postgres  | 	            
postgres  | 	      -- fixing up workspaceable rows for oauth2_authorization_codes
postgres  | 	
postgres  | 	      UPDATE oauth2_authorization_codes
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='oauth2_authorization_codes'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=oauth2_authorization_codes.id::text;
postgres  | 	            UPDATE oauth2_authorization_codes SET code = regexp_replace(code, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.883 UTC [93] LOG:  duration: 0.236 ms
postgres  | 2023-09-19 07:30:33.883 UTC [93] LOG:  statement:     SELECT table_name
postgres  | 	      FROM information_schema.tables
postgres  | 	     WHERE table_schema='public'
postgres  | 	  
postgres  | 2023-09-19 07:30:33.884 UTC [93] LOG:  duration: 0.363 ms
postgres  | 2023-09-19 07:30:33.884 UTC [93] LOG:  statement: BEGIN;              INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'oauth2_tokens', oauth2_tokens.id::text, 'access_token', oauth2_tokens.access_token
postgres  | 	              FROM oauth2_tokens;
postgres  | 	                          INSERT INTO ws_migrations_backup (entity_type, entity_id, unique_field_name, unique_field_value)
postgres  | 	              SELECT 'oauth2_tokens', oauth2_tokens.id::text, 'refresh_token', oauth2_tokens.refresh_token
postgres  | 	              FROM oauth2_tokens;
postgres  | 	            
postgres  | 	      -- fixing up workspaceable rows for oauth2_tokens
postgres  | 	
postgres  | 	      UPDATE oauth2_tokens
postgres  | 	      SET ws_id = we.workspace_id
postgres  | 	      FROM workspace_entities we
postgres  | 	      WHERE entity_type='oauth2_tokens'
postgres  | 	        AND unique_field_name='id'
postgres  | 	        AND unique_field_value=oauth2_tokens.id::text;
postgres  | 	            UPDATE oauth2_tokens SET access_token = regexp_replace(access_token, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', ''), refresh_token = regexp_replace(refresh_token, '^(' || (SELECT string_agg(name, '|') FROM workspaces) ||'):', '');
postgres  | 	      ;COMMIT
postgres  | 2023-09-19 07:30:33.884 UTC [93] LOG:  duration: 0.273 ms
postgres  | 2023-09-19 07:30:33.884 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise.oauth2', '001_1500_to_2100', ARRAY['001_1500_to_2100'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '001_1500_to_2100'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '001_1500_to_2100');
postgres  | 2023-09-19 07:30:33.885 UTC [93] LOG:  duration: 0.165 ms
postgres  | 2023-09-19 07:30:33.885 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, pending)
postgres  | 	     VALUES ('schema_meta', 'enterprise.oauth2', ARRAY['002_2200_to_2211'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET pending = ARRAY_APPEND(schema_meta.pending, '002_2200_to_2211');
postgres  | 2023-09-19 07:30:33.885 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.885 UTC [93] LOG:  statement:         SELECT app.consumer_id, oauth2_cred.client_id, app.ws_id 
postgres  | 	        FROM applications app 
postgres  | 	          LEFT JOIN oauth2_credentials oauth2_cred 
postgres  | 	          ON app.consumer_id = oauth2_cred.consumer_id AND app.ws_id = oauth2_cred.ws_id;
postgres  | 	      
postgres  | 2023-09-19 07:30:33.885 UTC [93] LOG:  duration: 0.146 ms
postgres  | 2023-09-19 07:30:33.885 UTC [93] LOG:  statement: INSERT INTO schema_meta (key, subsystem, last_executed, executed)
postgres  | 	     VALUES ('schema_meta', 'enterprise.oauth2', '002_2200_to_2211', ARRAY['002_2200_to_2211'])
postgres  | 	ON CONFLICT (key, subsystem) DO UPDATE
postgres  | 	        SET last_executed = EXCLUDED.last_executed,
postgres  | 	            executed = ARRAY_APPEND(COALESCE(schema_meta.executed, ARRAY[]::TEXT[]), '002_2200_to_2211'),
postgres  | 	            pending  = ARRAY_REMOVE(COALESCE(schema_meta.pending,  ARRAY[]::TEXT[]), '002_2200_to_2211');
postgres  | 2023-09-19 07:30:33.885 UTC [93] LOG:  duration: 0.152 ms
postgres  | 2023-09-19 07:30:33.887 UTC [94] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:33.887 UTC [94] LOG:  duration: 0.116 ms
postgres  | 2023-09-19 07:30:33.887 UTC [94] LOG:  statement: TRUNCATE "plugins" RESTART IDENTITY CASCADE;
postgres  | 2023-09-19 07:30:33.895 UTC [94] LOG:  duration: 7.611 ms
postgres  | 2023-09-19 07:30:33.926 UTC [94] LOG:  statement: TRUNCATE "tags" RESTART IDENTITY CASCADE;
postgres  | 2023-09-19 07:30:33.928 UTC [94] LOG:  duration: 1.697 ms
postgres  | 2023-09-19 07:30:33.929 UTC [94] LOG:  statement: SELECT table_name
postgres  | 	  FROM information_schema.tables
postgres  | 	 WHERE table_schema = CURRENT_SCHEMA;
postgres  | 	
postgres  | 2023-09-19 07:30:33.930 UTC [94] LOG:  duration: 1.183 ms
postgres  | 2023-09-19 07:30:33.930 UTC [94] LOG:  statement: TRUNCATE "services", "clustering_data_planes", "cluster_events", "snis", "consumers", "plugins", "certificates", "tags", "routes", "ca_certificates", "targets", "upstreams", "workspaces", "sm_vaults", "key_sets", "keys", "filter_chains", "acls", "acme_storage", "basicauth_credentials", "hmacauth_credentials", "jwt_secrets", "keyauth_credentials", "oauth2_credentials", "response_ratelimiting_metrics", "oauth2_tokens", "ratelimiting_metrics", "sessions", "rl_counters", "oauth2_authorization_codes", "vitals_stats_hours", "vitals_stats_seconds", "vitals_stats_minutes", "vitals_node_meta", "vitals_code_classes_by_cluster", "vitals_codes_by_route", "vitals_codes_by_consumer_route", "vitals_code_classes_by_workspace", "vitals_locks", "workspace_entities", "workspace_entity_counters", "rbac_user_roles", "legacy_files", "rbac_role_endpoints", "rbac_role_entities", "files", "rbac_roles", "rbac_users", "developers", "consumer_reset_secrets", "admins", "audit_objects", "audit_requests", "credentials", "login_attempts", "license_data", "document_objects", "event_hooks", "applications", "group_rbac_roles", "application_instances", "groups", "keyring_meta", "ws_migrations_backup", "vitals_stats_days", "licenses", "consumer_group_consumers", "consumer_group_plugins", "consumer_groups", "keyring_keys" RESTART IDENTITY CASCADE;
postgres  | 2023-09-19 07:30:34.033 UTC [94] LOG:  duration: 102.227 ms
postgres  | 2023-09-19 07:30:34.034 UTC [94] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:34.034 UTC [94] LOG:  duration: 0.564 ms
postgres  | 2023-09-19 07:30:34.035 UTC [94] LOG:  statement: INSERT INTO "workspaces" ("id", "name", "comment", "created_at", "updated_at", "meta", "config")
postgres  | 	     VALUES ('afd329ce-f351-4e87-9391-9ba916d3f4b0', 'default', NULL, TO_TIMESTAMP(1695108634) AT TIME ZONE 'UTC', TO_TIMESTAMP(1695108634) AT TIME ZONE 'UTC', '{"thumbnail":null,"color":null}', '{"portal_token_exp":null,"portal_invite_email":null,"portal_access_request_email":null,"portal_approved_email":null,"portal_reset_email":null,"portal_application_request_email":null,"portal_application_status_email":null,"portal_session_conf":null,"portal_reset_success_email":null,"portal_emails_from":null,"portal_auth":null,"portal_smtp_admin_emails":null,"portal_cors_origins":null,"portal_developer_meta_fields":"[{\"label\":\"Full Name\",\"title\":\"full_name\",\"validator\":{\"required\":true,\"type\":\"string\"}}]","portal_is_legacy":null,"portal":false,"portal_auto_approve":null,"portal_auth_conf":null,"meta":null,"portal_emails_reply_to":null}')
postgres  | 	  RETURNING "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config";
postgres  | 2023-09-19 07:30:34.035 UTC [94] LOG:  duration: 0.314 ms
postgres  | 2023-09-19 07:30:34.036 UTC [94] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:34.036 UTC [94] LOG:  duration: 0.086 ms
postgres  | 2023-09-19 07:30:34.361 UTC [95] LOG:  statement: SELECT CURRENT_SCHEMA AS schema
postgres  | 2023-09-19 07:30:34.361 UTC [95] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:34.361 UTC [95] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:34.361 UTC [95] LOG:  duration: 0.123 ms
postgres  | 2023-09-19 07:30:34.361 UTC [95] LOG:  statement: SHOW server_version_num;
postgres  | 2023-09-19 07:30:34.361 UTC [95] LOG:  duration: 0.038 ms
postgres  | 2023-09-19 07:30:34.386 UTC [95] LOG:  statement: SELECT table_name
postgres  | 	  FROM information_schema.tables
postgres  | 	 WHERE table_schema = CURRENT_SCHEMA;
postgres  | 	
postgres  | 2023-09-19 07:30:34.387 UTC [95] LOG:  duration: 1.516 ms
postgres  | 2023-09-19 07:30:34.391 UTC [95] LOG:  statement: SELECT *
postgres  | 	  FROM schema_meta
postgres  | 	 WHERE key = 'schema_meta';
postgres  | 2023-09-19 07:30:34.392 UTC [95] LOG:  duration: 0.244 ms
postgres  | 2023-09-19 07:30:34.463 UTC [96] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:34.464 UTC [96] LOG:  duration: 0.145 ms
postgres  | 2023-09-19 07:30:34.464 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='jwt_secrets';
postgres  | 2023-09-19 07:30:34.466 UTC [96] LOG:  duration: 2.430 ms
postgres  | 2023-09-19 07:30:34.467 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='plugins';
postgres  | 2023-09-19 07:30:34.467 UTC [96] LOG:  duration: 0.867 ms
postgres  | 2023-09-19 07:30:34.468 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='sm_vaults';
postgres  | 2023-09-19 07:30:34.469 UTC [96] LOG:  duration: 0.772 ms
postgres  | 2023-09-19 07:30:34.469 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='keyauth_credentials';
postgres  | 2023-09-19 07:30:34.470 UTC [96] LOG:  duration: 0.742 ms
postgres  | 2023-09-19 07:30:34.470 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='keys';
postgres  | 2023-09-19 07:30:34.471 UTC [96] LOG:  duration: 0.789 ms
postgres  | 2023-09-19 07:30:34.471 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='services';
postgres  | 2023-09-19 07:30:34.472 UTC [96] LOG:  duration: 0.800 ms
postgres  | 2023-09-19 07:30:34.472 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='targets';
postgres  | 2023-09-19 07:30:34.473 UTC [96] LOG:  duration: 0.749 ms
postgres  | 2023-09-19 07:30:34.473 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='oauth2_credentials';
postgres  | 2023-09-19 07:30:34.474 UTC [96] LOG:  duration: 0.765 ms
postgres  | 2023-09-19 07:30:34.474 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='acls';
postgres  | 2023-09-19 07:30:34.475 UTC [96] LOG:  duration: 1.093 ms
postgres  | 2023-09-19 07:30:34.475 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='developers';
postgres  | 2023-09-19 07:30:34.476 UTC [96] LOG:  duration: 0.771 ms
postgres  | 2023-09-19 07:30:34.476 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='files';
postgres  | 2023-09-19 07:30:34.477 UTC [96] LOG:  duration: 0.754 ms
postgres  | 2023-09-19 07:30:34.477 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='rbac_roles';
postgres  | 2023-09-19 07:30:34.478 UTC [96] LOG:  duration: 0.762 ms
postgres  | 2023-09-19 07:30:34.478 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='key_sets';
postgres  | 2023-09-19 07:30:34.479 UTC [96] LOG:  duration: 0.755 ms
postgres  | 2023-09-19 07:30:34.480 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='filter_chains';
postgres  | 2023-09-19 07:30:34.480 UTC [96] LOG:  duration: 0.744 ms
postgres  | 2023-09-19 07:30:34.480 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='applications';
postgres  | 2023-09-19 07:30:34.481 UTC [96] LOG:  duration: 0.785 ms
postgres  | 2023-09-19 07:30:34.482 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='rbac_users';
postgres  | 2023-09-19 07:30:34.482 UTC [96] LOG:  duration: 0.772 ms
postgres  | 2023-09-19 07:30:34.483 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='snis';
postgres  | 2023-09-19 07:30:34.483 UTC [96] LOG:  duration: 0.743 ms
postgres  | 2023-09-19 07:30:34.484 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='consumer_groups';
postgres  | 2023-09-19 07:30:34.484 UTC [96] LOG:  duration: 0.739 ms
postgres  | 2023-09-19 07:30:34.484 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='consumer_group_plugins';
postgres  | 2023-09-19 07:30:34.485 UTC [96] LOG:  duration: 0.736 ms
postgres  | 2023-09-19 07:30:34.485 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='application_instances';
postgres  | 2023-09-19 07:30:34.486 UTC [96] LOG:  duration: 0.751 ms
postgres  | 2023-09-19 07:30:34.486 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='document_objects';
postgres  | 2023-09-19 07:30:34.487 UTC [96] LOG:  duration: 0.731 ms
postgres  | 2023-09-19 07:30:34.487 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='oauth2_tokens';
postgres  | 2023-09-19 07:30:34.488 UTC [96] LOG:  duration: 0.758 ms
postgres  | 2023-09-19 07:30:34.488 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='certificates';
postgres  | 2023-09-19 07:30:34.489 UTC [96] LOG:  duration: 0.803 ms
postgres  | 2023-09-19 07:30:34.489 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='consumers';
postgres  | 2023-09-19 07:30:34.490 UTC [96] LOG:  duration: 0.760 ms
postgres  | 2023-09-19 07:30:34.490 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='routes';
postgres  | 2023-09-19 07:30:34.491 UTC [96] LOG:  duration: 0.775 ms
postgres  | 2023-09-19 07:30:34.491 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='upstreams';
postgres  | 2023-09-19 07:30:34.492 UTC [96] LOG:  duration: 0.772 ms
postgres  | 2023-09-19 07:30:34.492 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='oauth2_authorization_codes';
postgres  | 2023-09-19 07:30:34.493 UTC [96] LOG:  duration: 0.748 ms
postgres  | 2023-09-19 07:30:34.493 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='basicauth_credentials';
postgres  | 2023-09-19 07:30:34.494 UTC [96] LOG:  duration: 0.749 ms
postgres  | 2023-09-19 07:30:34.494 UTC [96] LOG:  statement: SELECT column_name FROM information_schema.columns WHERE table_schema='public' and table_name='hmacauth_credentials';
postgres  | 2023-09-19 07:30:34.495 UTC [96] LOG:  duration: 0.729 ms
postgres  | 2023-09-19 07:30:34.777 UTC [97] LOG:  statement: SELECT CURRENT_SCHEMA AS schema
postgres  | 2023-09-19 07:30:34.777 UTC [97] LOG:  duration: 0.179 ms
postgres  | 2023-09-19 07:30:34.777 UTC [97] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:34.777 UTC [97] LOG:  duration: 0.110 ms
postgres  | 2023-09-19 07:30:34.777 UTC [97] LOG:  statement: SHOW server_version_num;
postgres  | 2023-09-19 07:30:34.777 UTC [97] LOG:  duration: 0.041 ms
postgres  | 2023-09-19 07:30:34.800 UTC [98] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:34.800 UTC [98] LOG:  duration: 0.133 ms
postgres  | 2023-09-19 07:30:34.800 UTC [98] LOG:  statement: SELECT table_name
postgres  | 	  FROM information_schema.tables
postgres  | 	 WHERE table_schema = CURRENT_SCHEMA;
postgres  | 	
postgres  | 2023-09-19 07:30:34.802 UTC [98] LOG:  duration: 1.458 ms
postgres  | 2023-09-19 07:30:34.806 UTC [98] LOG:  statement: SELECT *
postgres  | 	  FROM schema_meta
postgres  | 	 WHERE key = 'schema_meta';
postgres  | 2023-09-19 07:30:34.806 UTC [98] LOG:  duration: 0.184 ms
postgres  | 2023-09-19 07:30:34.809 UTC [99] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:34.809 UTC [99] LOG:  duration: 0.109 ms
postgres  | 2023-09-19 07:30:34.810 UTC [99] LOG:  statement:   SELECT "id", "payload", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at"
postgres  | 	    FROM "licenses"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:34.810 UTC [99] LOG:  duration: 0.434 ms
postgres  | 2023-09-19 07:30:34.810 UTC [99] LOG:  statement:   SELECT "id", "payload", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at"
postgres  | 	    FROM "licenses"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:34.810 UTC [99] LOG:  duration: 0.066 ms
postgres  | 2023-09-19 07:30:39.900 UTC [99] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:39.901 UTC [99] LOG:  duration: 0.601 ms
postgres  | 2023-09-19 07:30:39.901 UTC [99] LOG:  statement:   SELECT "id", "name", "instance_name", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "route_id", "service_id", "consumer_id", "consumer_group_id", "config", "protocols", "enabled", "tags", "ordering", "ws_id"
postgres  | 	    FROM "plugins"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 50001;
postgres  | 2023-09-19 07:30:39.902 UTC [99] LOG:  duration: 0.351 ms
postgres  | 2023-09-19 07:30:39.902 UTC [99] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "name", "retries", "protocol", "host", "port", "path", "connect_timeout", "write_timeout", "read_timeout", "tags", "client_certificate_id", "tls_verify", "tls_verify_depth", "ca_certificates", "enabled", "ws_id"
postgres  | 	    FROM "services"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 50001;
postgres  | 2023-09-19 07:30:39.902 UTC [99] LOG:  duration: 0.235 ms
postgres  | 2023-09-19 07:30:39.902 UTC [99] LOG:  statement:   SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	    FROM "workspaces"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 50001;
postgres  | 2023-09-19 07:30:39.902 UTC [99] LOG:  duration: 0.088 ms
postgres  | 2023-09-19 07:30:39.903 UTC [99] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "name", "protocols", "methods", "hosts", "paths", "headers", "https_redirect_status_code", "regex_priority", "strip_path", "path_handling", "preserve_host", "request_buffering", "response_buffering", "snis", "sources", "destinations", "tags", "service_id", "ws_id"
postgres  | 	    FROM "routes"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 50001;
postgres  | 2023-09-19 07:30:39.903 UTC [99] LOG:  duration: 0.206 ms
postgres  | 2023-09-19 07:30:39.942 UTC [107] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.942 UTC [107] LOG:  duration: 0.155 ms
postgres  | 2023-09-19 07:30:39.942 UTC [107] LOG:  statement: SELECT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	
postgres  | 2023-09-19 07:30:39.942 UTC [107] LOG:  duration: 0.234 ms
postgres  | 2023-09-19 07:30:39.944 UTC [108] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.944 UTC [108] LOG:  duration: 0.101 ms
postgres  | 2023-09-19 07:30:39.944 UTC [108] LOG:  statement:   CREATE TABLE IF NOT EXISTS vitals_stats_seconds_1695106800
postgres  | 	  (LIKE vitals_stats_seconds INCLUDING defaults INCLUDING constraints INCLUDING indexes);
postgres  | 	
postgres  | 2023-09-19 07:30:39.946 UTC [108] LOG:  duration: 1.731 ms
postgres  | 2023-09-19 07:30:39.948 UTC [109] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.948 UTC [109] LOG:  duration: 0.108 ms
postgres  | 2023-09-19 07:30:39.948 UTC [109] LOG:  statement:   CREATE TABLE IF NOT EXISTS vitals_stats_seconds_1695110400
postgres  | 	  (LIKE vitals_stats_seconds INCLUDING defaults INCLUDING constraints INCLUDING indexes);
postgres  | 	
postgres  | 2023-09-19 07:30:39.949 UTC [109] LOG:  duration: 1.384 ms
postgres  | 2023-09-19 07:30:39.951 UTC [110] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.951 UTC [110] LOG:  duration: 0.105 ms
postgres  | 2023-09-19 07:30:39.951 UTC [110] LOG:  statement: insert into vitals_node_meta (node_id, hostname, first_report, last_report) values('{863d5a89-1bcb-4623-bd8d-fc311aa7a9df}', 'ubuntu', now(), now()) on conflict(node_id) do nothing
postgres  | 2023-09-19 07:30:39.952 UTC [110] LOG:  duration: 0.573 ms
postgres  | 2023-09-19 07:30:39.954 UTC [111] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.954 UTC [111] LOG:  duration: 0.099 ms
postgres  | 2023-09-19 07:30:39.954 UTC [111] LOG:  statement:   INSERT INTO license_data (node_id, license_creation_date, req_cnt, year, month)
postgres  | 	  VALUES ('863d5a89-1bcb-4623-bd8d-fc311aa7a9df', '2017-07-20', 0, 2023, 9)
postgres  | 	  ON CONFLICT (node_id, year, month)
postgres  | 	  DO UPDATE SET req_cnt = license_data.req_cnt + excluded.req_cnt;
postgres  | 	
postgres  | 2023-09-19 07:30:39.954 UTC [111] LOG:  duration: 0.460 ms
postgres  | 2023-09-19 07:30:39.967 UTC [112] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.967 UTC [112] LOG:  duration: 0.152 ms
postgres  | 2023-09-19 07:30:39.968 UTC [112] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "name", "retries", "protocol", "host", "port", "path", "connect_timeout", "write_timeout", "read_timeout", "tags", "client_certificate_id", "tls_verify", "tls_verify_depth", "ca_certificates", "enabled", "ws_id"
postgres  | 	    FROM "services"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 50001;
postgres  | 2023-09-19 07:30:39.968 UTC [112] LOG:  duration: 0.810 ms
postgres  | 2023-09-19 07:30:39.973 UTC [113] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.973 UTC [113] LOG:  duration: 0.116 ms
postgres  | 2023-09-19 07:30:39.974 UTC [113] LOG:  statement:   SELECT "id", "payload", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at"
postgres  | 	    FROM "licenses"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:39.974 UTC [113] LOG:  duration: 0.411 ms
postgres  | 2023-09-19 07:30:39.976 UTC [114] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.976 UTC [114] LOG:  duration: 0.109 ms
postgres  | 2023-09-19 07:30:39.976 UTC [114] LOG:  statement:   SELECT "id", "payload", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at"
postgres  | 	    FROM "licenses"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:39.976 UTC [114] LOG:  duration: 0.373 ms
postgres  | 2023-09-19 07:30:39.984 UTC [94] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:39.984 UTC [94] LOG:  duration: 0.217 ms
postgres  | 2023-09-19 07:30:39.987 UTC [94] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  'f84d186e-0318-4eb0-ba87-0d03a6fa5600',
postgres  | 	  '53cae652-3c31-48e4-baff-97109a78cd10',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'workspaces:afd329ce-f351-4e87-9391-9ba916d3f4b0:::::'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:39.988 UTC [115] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:39.988 UTC [115] LOG:  duration: 0.152 ms
postgres  | 2023-09-19 07:30:39.988 UTC [115] LOG:  statement:   SELECT "id",
postgres  | 	         "node_id",
postgres  | 	         "channel",
postgres  | 	         "data",
postgres  | 	         EXTRACT(EPOCH FROM "at"  AT TIME ZONE 'UTC') AS "at",
postgres  | 	         EXTRACT(EPOCH FROM "nbf" AT TIME ZONE 'UTC') AS "nbf",
postgres  | 	         EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	    FROM "cluster_events"
postgres  | 	   WHERE "channel" IN ('invalidations')
postgres  | 	     AND "at" >  TO_TIMESTAMP(1695108633.477) AT TIME ZONE 'UTC'
postgres  | 	     AND "at" <= CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'
postgres  | 	ORDER BY "at"
postgres  | 	   LIMIT 1000
postgres  | 	  OFFSET 0
postgres  | 	
postgres  | 2023-09-19 07:30:39.989 UTC [94] LOG:  duration: 1.724 ms
postgres  | 2023-09-19 07:30:39.989 UTC [115] LOG:  duration: 0.619 ms
postgres  | 2023-09-19 07:30:39.989 UTC [94] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:39.989 UTC [94] LOG:  duration: 0.088 ms
postgres  | 2023-09-19 07:30:39.990 UTC [94] LOG:  statement: INSERT INTO "workspaces" ("id", "name", "comment", "created_at", "updated_at", "meta", "config")
postgres  | 	     VALUES ('97bb8712-1c91-4091-8f18-a1152bd24e66', 'default', NULL, TO_TIMESTAMP(1695108639) AT TIME ZONE 'UTC', TO_TIMESTAMP(1695108639) AT TIME ZONE 'UTC', '{"thumbnail":null,"color":null}', '{"portal_token_exp":null,"portal_invite_email":null,"portal_access_request_email":null,"portal_approved_email":null,"portal_reset_email":null,"portal_application_request_email":null,"portal_application_status_email":null,"portal_session_conf":null,"portal_reset_success_email":null,"portal_emails_from":null,"portal_auth":"basic-auth","portal_smtp_admin_emails":null,"portal_cors_origins":null,"portal_developer_meta_fields":"[{\"label\":\"Full Name\",\"title\":\"full_name\",\"validator\":{\"required\":true,\"type\":\"string\"}}]","portal_is_legacy":null,"portal":true,"portal_auto_approve":true,"portal_auth_conf":null,"meta":null,"portal_emails_reply_to":null}')
postgres  | 	ON CONFLICT ("name") DO UPDATE
postgres  | 	        SET "name" = EXCLUDED."name", "comment" = EXCLUDED."comment", "created_at" = EXCLUDED."created_at", "updated_at" = EXCLUDED."updated_at", "meta" = EXCLUDED."meta", "config" = EXCLUDED."config"
postgres  | 	  RETURNING "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config";
postgres  | 2023-09-19 07:30:39.990 UTC [94] LOG:  duration: 0.293 ms
postgres  | 2023-09-19 07:30:40.014 UTC [117] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:40.014 UTC [117] LOG:  duration: 0.150 ms
postgres  | 2023-09-19 07:30:40.014 UTC [118] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:40.014 UTC [118] LOG:  duration: 0.104 ms
postgres  | 2023-09-19 07:30:40.015 UTC [116] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:40.015 UTC [116] LOG:  duration: 0.096 ms
postgres  | 2023-09-19 07:30:40.015 UTC [119] LOG:  statement: SET SCHEMA 'public';
postgres  | 	SET TIME ZONE 'UTC';
postgres  | 2023-09-19 07:30:40.015 UTC [119] LOG:  duration: 0.086 ms
postgres  | 2023-09-19 07:30:40.015 UTC [117] LOG:  statement:   SELECT "workspace_id", "entity_type", "count"
postgres  | 	    FROM "workspace_entity_counters"
postgres  | 	ORDER BY "workspace_id", "entity_type"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:40.015 UTC [118] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "source", "event", "on_change", "snooze", "handler", "config"
postgres  | 	    FROM "event_hooks"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:40.015 UTC [116] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", "name", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "algorithm", "hash_on", "hash_fallback", "hash_on_header", "hash_fallback_header", "hash_on_cookie", "hash_on_cookie_path", "hash_on_query_arg", "hash_fallback_query_arg", "hash_on_uri_capture", "hash_fallback_uri_capture", "slots", "healthchecks", "tags", "host_header", "client_certificate_id", "use_srv_name", "ws_id"
postgres  | 	    FROM "upstreams"
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 50001;
postgres  | 2023-09-19 07:30:40.015 UTC [119] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.016 UTC [117] LOG:  duration: 0.506 ms
postgres  | 2023-09-19 07:30:40.016 UTC [118] LOG:  duration: 0.440 ms
postgres  | 2023-09-19 07:30:40.016 UTC [116] LOG:  duration: 0.524 ms
postgres  | 2023-09-19 07:30:40.016 UTC [119] LOG:  duration: 0.403 ms
postgres  | 2023-09-19 07:30:40.017 UTC [119] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE ("id") = ('afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.017 UTC [119] LOG:  duration: 0.214 ms
postgres  | 2023-09-19 07:30:40.018 UTC [119] LOG:  statement: INSERT INTO "consumers" ("id", "created_at", "updated_at", "username", "custom_id", "type", "tags", "username_lower", "ws_id")
postgres  | 	     VALUES ('2b1e9c07-0aae-4980-9e8b-5a10bfbad22f', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', 'kongkong@konghq.com', NULL, 1, NULL, 'kongkong@konghq.com', 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	  RETURNING "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "username", "custom_id", "type", "tags", "username_lower", "ws_id";
postgres  | 2023-09-19 07:30:40.020 UTC [119] LOG:  duration: 1.491 ms
postgres  | 2023-09-19 07:30:40.021 UTC [119] LOG:  statement: INSERT INTO "basicauth_credentials" ("id", "created_at", "consumer_id", "username", "password", "tags", "ws_id")
postgres  | 	     VALUES ('da79ef63-d510-448b-a90b-1fcb27b309fd', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', '2b1e9c07-0aae-4980-9e8b-5a10bfbad22f', 'kongkong@konghq.com', '74dfe0f22f8d789b34bfa9ea8cb1ae326558028e', NULL, 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	  RETURNING "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", "consumer_id", "username", "password", "tags", "ws_id";
postgres  | 2023-09-19 07:30:40.021 UTC [116] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  'aaa842b3-5cf7-4e24-b59f-c7b475dff9f7',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'consumers:2b1e9c07-0aae-4980-9e8b-5a10bfbad22f:::::afd329ce-f351-4e87-9391-9ba916d3f4b0'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.021 UTC [119] LOG:  duration: 0.543 ms
postgres  | 2023-09-19 07:30:40.022 UTC [116] LOG:  duration: 0.972 ms
postgres  | 2023-09-19 07:30:40.022 UTC [119] LOG:  statement:       INSERT INTO workspace_entity_counters(workspace_id, entity_type, count)
postgres  | 	      VALUES('afd329ce-f351-4e87-9391-9ba916d3f4b0', 'basicauth_credentials', 1)
postgres  | 	      ON CONFLICT(workspace_id, entity_type) DO
postgres  | 	      UPDATE SET COUNT = workspace_entity_counters.count + excluded.count
postgres  | 2023-09-19 07:30:40.022 UTC [116] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  '7a9cbefa-06ec-4880-b6d0-507c672e5c2b',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'consumers:kongkong@konghq.com:::::afd329ce-f351-4e87-9391-9ba916d3f4b0'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.022 UTC [119] LOG:  duration: 0.272 ms
postgres  | 2023-09-19 07:30:40.022 UTC [116] LOG:  duration: 0.245 ms
postgres  | 2023-09-19 07:30:40.023 UTC [119] LOG:  statement: INSERT INTO "credentials" ("id", "consumer_id", "consumer_type", "plugin", "credential_data", "created_at", "updated_at")
postgres  | 	     VALUES ('da79ef63-d510-448b-a90b-1fcb27b309fd', '2b1e9c07-0aae-4980-9e8b-5a10bfbad22f', 1, 'basic-auth', '{"password":"74dfe0f22f8d789b34bfa9ea8cb1ae326558028e","created_at":1695108640,"id":"da79ef63-d510-448b-a90b-1fcb27b309fd","username":"kongkong@konghq.com","consumer":{"id":"2b1e9c07-0aae-4980-9e8b-5a10bfbad22f"}}', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC')
postgres  | 	  RETURNING "id", "consumer_id", "consumer_type", "plugin", "credential_data", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at";
postgres  | 2023-09-19 07:30:40.023 UTC [119] LOG:  duration: 0.357 ms
postgres  | 2023-09-19 07:30:40.024 UTC [119] LOG:  statement: INSERT INTO "developers" ("id", "created_at", "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id")
postgres  | 	     VALUES ('bdb6380b-ed04-4640-b36b-a7bbe134cc91', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', 'kongkong@konghq.com', 5, NULL, '2b1e9c07-0aae-4980-9e8b-5a10bfbad22f', '{"full_name":"1337"}', NULL, 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	  RETURNING "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id";
postgres  | 2023-09-19 07:30:40.024 UTC [116] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  '02a89113-b01f-437d-8676-4014600e62bc',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'basicauth_credentials:kongkong@konghq.com:::::afd329ce-f351-4e87-9391-9ba916d3f4b0'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.024 UTC [119] LOG:  duration: 0.619 ms
postgres  | 2023-09-19 07:30:40.024 UTC [116] LOG:  duration: 0.480 ms
postgres  | 2023-09-19 07:30:40.025 UTC [119] LOG:  statement:       INSERT INTO workspace_entity_counters(workspace_id, entity_type, count)
postgres  | 	      VALUES('afd329ce-f351-4e87-9391-9ba916d3f4b0', 'developers', 1)
postgres  | 	      ON CONFLICT(workspace_id, entity_type) DO
postgres  | 	      UPDATE SET COUNT = workspace_entity_counters.count + excluded.count
postgres  | 2023-09-19 07:30:40.025 UTC [119] LOG:  duration: 0.168 ms
postgres  | 2023-09-19 07:30:40.025 UTC [116] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  'baede53c-8a2d-47a7-a4f4-4f40fd700e48',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'credentials:da79ef63-d510-448b-a90b-1fcb27b309fd:::::'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.025 UTC [119] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "consumer_id", "secret", "status", "client_addr"
postgres  | 	    FROM "consumer_reset_secrets"
postgres  | 	   WHERE ("consumer_id") = ('2b1e9c07-0aae-4980-9e8b-5a10bfbad22f')
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:40.025 UTC [116] LOG:  duration: 0.235 ms
postgres  | 2023-09-19 07:30:40.025 UTC [119] LOG:  duration: 0.210 ms
postgres  | 2023-09-19 07:30:40.026 UTC [119] LOG:  statement: INSERT INTO "consumer_reset_secrets" ("id", "created_at", "updated_at", "consumer_id", "secret", "status", "client_addr")
postgres  | 	     VALUES ('c2016744-acd0-4af3-b143-20320b634661', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', '2b1e9c07-0aae-4980-9e8b-5a10bfbad22f', 'x6nyTik0x9q1QOtq7KNuwByKeTPESL2g', 1, '127.0.0.1')
postgres  | 	  RETURNING "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "consumer_id", "secret", "status", "client_addr";
postgres  | 2023-09-19 07:30:40.026 UTC [119] LOG:  duration: 0.244 ms
postgres  | 2023-09-19 07:30:40.027 UTC [119] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "path", "contents", "checksum", "ws_id"
postgres  | 	  FROM "files"
postgres  | 	 WHERE "path" = 'emails/account-verification.txt'
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.027 UTC [119] LOG:  duration: 0.179 ms
postgres  | 2023-09-19 07:30:40.028 UTC [116] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  'a1b07a3b-652d-41a5-86df-815b33b8d67a',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'developers:kongkong@konghq.com:::::afd329ce-f351-4e87-9391-9ba916d3f4b0'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.028 UTC [116] LOG:  duration: 0.283 ms
postgres  | 2023-09-19 07:30:40.029 UTC [116] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  '8e420804-7a8e-402e-bef9-900c397115cf',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'consumer_reset_secrets:c2016744-acd0-4af3-b143-20320b634661:::::'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.030 UTC [116] LOG:  duration: 0.346 ms
postgres  | 2023-09-19 07:30:40.031 UTC [94] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "consumer_id", "secret", "status", "client_addr"
postgres  | 	    FROM "consumer_reset_secrets"
postgres  | 	   WHERE ("consumer_id") = ('2b1e9c07-0aae-4980-9e8b-5a10bfbad22f')
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:40.031 UTC [94] LOG:  duration: 0.285 ms
postgres  | 2023-09-19 07:30:40.031 UTC [94] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.031 UTC [94] LOG:  duration: 0.090 ms
postgres  | 2023-09-19 07:30:40.032 UTC [94] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  'a0516708-c3d2-4379-aa87-a9772ace43c7',
postgres  | 	  '53cae652-3c31-48e4-baff-97109a78cd10',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'workspaces:afd329ce-f351-4e87-9391-9ba916d3f4b0:::::'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.032 UTC [94] LOG:  duration: 0.303 ms
postgres  | 2023-09-19 07:30:40.032 UTC [94] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.033 UTC [94] LOG:  duration: 0.081 ms
postgres  | 2023-09-19 07:30:40.033 UTC [94] LOG:  statement: INSERT INTO "workspaces" ("id", "name", "comment", "created_at", "updated_at", "meta", "config")
postgres  | 	     VALUES ('be936842-af7e-4b71-806f-1eaa70118d17', 'default', NULL, TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', '{"thumbnail":null,"color":null}', '{"portal_token_exp":null,"portal_invite_email":null,"portal_access_request_email":null,"portal_approved_email":null,"portal_reset_email":null,"portal_application_request_email":null,"portal_application_status_email":null,"portal_session_conf":null,"portal_reset_success_email":null,"portal_emails_from":null,"portal_auth":"basic-auth","portal_smtp_admin_emails":null,"portal_cors_origins":null,"portal_developer_meta_fields":"[{\"label\":\"Full Name\",\"title\":\"full_name\",\"validator\":{\"required\":true,\"type\":\"string\"}}]","portal_is_legacy":null,"portal":true,"portal_auto_approve":false,"portal_auth_conf":null,"meta":null,"portal_emails_reply_to":null}')
postgres  | 	ON CONFLICT ("name") DO UPDATE
postgres  | 	        SET "name" = EXCLUDED."name", "comment" = EXCLUDED."comment", "created_at" = EXCLUDED."created_at", "updated_at" = EXCLUDED."updated_at", "meta" = EXCLUDED."meta", "config" = EXCLUDED."config"
postgres  | 	  RETURNING "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config";
postgres  | 2023-09-19 07:30:40.033 UTC [94] LOG:  duration: 0.217 ms
postgres  | 2023-09-19 07:30:40.034 UTC [94] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id"
postgres  | 	  FROM "developers"
postgres  | 	 WHERE ("id") = ('bdb6380b-ed04-4640-b36b-a7bbe134cc91')
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.034 UTC [94] LOG:  duration: 0.199 ms
postgres  | 2023-09-19 07:30:40.094 UTC [116] LOG:  statement:   SELECT "id",
postgres  | 	         "node_id",
postgres  | 	         "channel",
postgres  | 	         "data",
postgres  | 	         EXTRACT(EPOCH FROM "at"  AT TIME ZONE 'UTC') AS "at",
postgres  | 	         EXTRACT(EPOCH FROM "nbf" AT TIME ZONE 'UTC') AS "nbf",
postgres  | 	         EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	    FROM "cluster_events"
postgres  | 	   WHERE "channel" IN ('invalidations', 'log_level', 'balancer:targets', 'balancer:post_health', 'balancer:upstreams', 'portal:router', 'proxy-cache:purge')
postgres  | 	     AND "at" >  TO_TIMESTAMP(1695108639.942) AT TIME ZONE 'UTC'
postgres  | 	     AND "at" <= CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'
postgres  | 	ORDER BY "at"
postgres  | 	   LIMIT 1000
postgres  | 	  OFFSET 0
postgres  | 	
postgres  | 2023-09-19 07:30:40.095 UTC [116] LOG:  duration: 0.522 ms
postgres  | 2023-09-19 07:30:40.115 UTC [116] LOG:  statement:   INSERT INTO vitals_stats_seconds_1695106800 (at, node_id, l2_hit, l2_miss, plat_min, plat_max, ulat_min,
postgres  | 	    ulat_max, requests, plat_count, plat_total, ulat_count, ulat_total)
postgres  | 	  VALUES (1695108639, '863d5a89-1bcb-4623-bd8d-fc311aa7a9df', 1, 0, null, null, null, null, 0, 0, 0, 0, 0)
postgres  | 	  ON CONFLICT (node_id, at) DO UPDATE SET
postgres  | 	    l2_hit = vitals_stats_seconds_1695106800.l2_hit + excluded.l2_hit,
postgres  | 	    l2_miss = vitals_stats_seconds_1695106800.l2_miss + excluded.l2_miss,
postgres  | 	    plat_min = least(vitals_stats_seconds_1695106800.plat_min, excluded.plat_min),
postgres  | 	    plat_max = greatest(vitals_stats_seconds_1695106800.plat_max, excluded.plat_max),
postgres  | 	    ulat_min = least(vitals_stats_seconds_1695106800.ulat_min, excluded.ulat_min),
postgres  | 	    ulat_max = greatest(vitals_stats_seconds_1695106800.ulat_max, excluded.ulat_max),
postgres  | 	    requests = vitals_stats_seconds_1695106800.requests + excluded.requests,
postgres  | 	    plat_count = vitals_stats_seconds_1695106800.plat_count + excluded.plat_count,
postgres  | 	    plat_total = vitals_stats_seconds_1695106800.plat_total + excluded.plat_total,
postgres  | 	    ulat_count = vitals_stats_seconds_1695106800.ulat_count + excluded.ulat_count,
postgres  | 	    ulat_total = vitals_stats_seconds_1695106800.ulat_total + excluded.ulat_total
postgres  | 	
postgres  | 2023-09-19 07:30:40.116 UTC [116] LOG:  duration: 0.533 ms
postgres  | 2023-09-19 07:30:40.116 UTC [116] LOG:  statement:   INSERT INTO vitals_stats_minutes (at, node_id, l2_hit, l2_miss, plat_min, plat_max, ulat_min,
postgres  | 	    ulat_max, requests, plat_count, plat_total, ulat_count, ulat_total)
postgres  | 	  VALUES (1695108600, '863d5a89-1bcb-4623-bd8d-fc311aa7a9df', 1, 0, null, null, null, null, 0, 0, 0, 0, 0)
postgres  | 	  ON CONFLICT (node_id, at) DO UPDATE SET
postgres  | 	    l2_hit = vitals_stats_minutes.l2_hit + excluded.l2_hit,
postgres  | 	    l2_miss = vitals_stats_minutes.l2_miss + excluded.l2_miss,
postgres  | 	    plat_min = least(vitals_stats_minutes.plat_min, excluded.plat_min),
postgres  | 	    plat_max = greatest(vitals_stats_minutes.plat_max, excluded.plat_max),
postgres  | 	    ulat_min = least(vitals_stats_minutes.ulat_min, excluded.ulat_min),
postgres  | 	    ulat_max = greatest(vitals_stats_minutes.ulat_max, excluded.ulat_max),
postgres  | 	    requests = vitals_stats_minutes.requests + excluded.requests,
postgres  | 	    plat_count = vitals_stats_minutes.plat_count + excluded.plat_count,
postgres  | 	    plat_total = vitals_stats_minutes.plat_total + excluded.plat_total,
postgres  | 	    ulat_count = vitals_stats_minutes.ulat_count + excluded.ulat_count,
postgres  | 	    ulat_total = vitals_stats_minutes.ulat_total + excluded.ulat_total
postgres  | 	
postgres  | 2023-09-19 07:30:40.116 UTC [116] LOG:  duration: 0.409 ms
postgres  | 2023-09-19 07:30:40.117 UTC [116] LOG:  statement: UPDATE vitals_node_meta SET last_report = now() WHERE node_id = '863d5a89-1bcb-4623-bd8d-fc311aa7a9df'
postgres  | 2023-09-19 07:30:40.117 UTC [116] LOG:  duration: 0.342 ms
postgres  | 2023-09-19 07:30:40.118 UTC [116] LOG:  statement: UPDATE vitals_node_meta SET last_report = now() WHERE node_id = '863d5a89-1bcb-4623-bd8d-fc311aa7a9df'
postgres  | 2023-09-19 07:30:40.118 UTC [116] LOG:  duration: 0.176 ms
postgres  | 2023-09-19 07:30:40.118 UTC [116] LOG:  statement: DELETE FROM vitals_stats_minutes WHERE at < 1695018640
postgres  | 2023-09-19 07:30:40.118 UTC [116] LOG:  duration: 0.095 ms
postgres  | 2023-09-19 07:30:40.118 UTC [116] LOG:  statement: DELETE FROM vitals_stats_days WHERE at < 1695108640
postgres  | 2023-09-19 07:30:40.118 UTC [116] LOG:  duration: 0.123 ms
postgres  | 2023-09-19 07:30:40.200 UTC [116] LOG:  statement:   SELECT "id",
postgres  | 	         "node_id",
postgres  | 	         "channel",
postgres  | 	         "data",
postgres  | 	         EXTRACT(EPOCH FROM "at"  AT TIME ZONE 'UTC') AS "at",
postgres  | 	         EXTRACT(EPOCH FROM "nbf" AT TIME ZONE 'UTC') AS "nbf",
postgres  | 	         EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	    FROM "cluster_events"
postgres  | 	   WHERE "channel" IN ('invalidations', 'log_level', 'balancer:targets', 'balancer:post_health', 'balancer:upstreams', 'portal:router', 'proxy-cache:purge')
postgres  | 	     AND "at" >  TO_TIMESTAMP(1695108640.094) AT TIME ZONE 'UTC'
postgres  | 	     AND "at" <= CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'
postgres  | 	ORDER BY "at"
postgres  | 	   LIMIT 1000
postgres  | 	  OFFSET 0
postgres  | 	
postgres  | 2023-09-19 07:30:40.200 UTC [116] LOG:  duration: 0.271 ms
postgres  | 2023-09-19 07:30:40.305 UTC [116] LOG:  statement:   SELECT "id",
postgres  | 	         "node_id",
postgres  | 	         "channel",
postgres  | 	         "data",
postgres  | 	         EXTRACT(EPOCH FROM "at"  AT TIME ZONE 'UTC') AS "at",
postgres  | 	         EXTRACT(EPOCH FROM "nbf" AT TIME ZONE 'UTC') AS "nbf",
postgres  | 	         EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	    FROM "cluster_events"
postgres  | 	   WHERE "channel" IN ('invalidations', 'log_level', 'balancer:targets', 'balancer:post_health', 'balancer:upstreams', 'portal:router', 'proxy-cache:purge')
postgres  | 	     AND "at" >  TO_TIMESTAMP(1695108640.094) AT TIME ZONE 'UTC'
postgres  | 	     AND "at" <= CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'
postgres  | 	ORDER BY "at"
postgres  | 	   LIMIT 1000
postgres  | 	  OFFSET 0
postgres  | 	
postgres  | 2023-09-19 07:30:40.305 UTC [116] LOG:  duration: 0.277 ms
postgres  | 2023-09-19 07:30:40.408 UTC [116] LOG:  statement:   SELECT "id",
postgres  | 	         "node_id",
postgres  | 	         "channel",
postgres  | 	         "data",
postgres  | 	         EXTRACT(EPOCH FROM "at"  AT TIME ZONE 'UTC') AS "at",
postgres  | 	         EXTRACT(EPOCH FROM "nbf" AT TIME ZONE 'UTC') AS "nbf",
postgres  | 	         EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	    FROM "cluster_events"
postgres  | 	   WHERE "channel" IN ('invalidations', 'log_level', 'balancer:targets', 'balancer:post_health', 'balancer:upstreams', 'portal:router', 'proxy-cache:purge')
postgres  | 	     AND "at" >  TO_TIMESTAMP(1695108640.094) AT TIME ZONE 'UTC'
postgres  | 	     AND "at" <= CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'
postgres  | 	ORDER BY "at"
postgres  | 	   LIMIT 1000
postgres  | 	  OFFSET 0
postgres  | 	
postgres  | 2023-09-19 07:30:40.409 UTC [116] LOG:  duration: 0.328 ms
postgres  | 2023-09-19 07:30:40.513 UTC [116] LOG:  statement:   SELECT "id",
postgres  | 	         "node_id",
postgres  | 	         "channel",
postgres  | 	         "data",
postgres  | 	         EXTRACT(EPOCH FROM "at"  AT TIME ZONE 'UTC') AS "at",
postgres  | 	         EXTRACT(EPOCH FROM "nbf" AT TIME ZONE 'UTC') AS "nbf",
postgres  | 	         EXTRACT(EPOCH FROM CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC') AS "now"
postgres  | 	    FROM "cluster_events"
postgres  | 	   WHERE "channel" IN ('invalidations', 'log_level', 'balancer:targets', 'balancer:post_health', 'balancer:upstreams', 'portal:router', 'proxy-cache:purge')
postgres  | 	     AND "at" >  TO_TIMESTAMP(1695108640.094) AT TIME ZONE 'UTC'
postgres  | 	     AND "at" <= CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC'
postgres  | 	ORDER BY "at"
postgres  | 	   LIMIT 1000
postgres  | 	  OFFSET 0
postgres  | 	
postgres  | 2023-09-19 07:30:40.513 UTC [116] LOG:  duration: 0.274 ms
postgres  | 2023-09-19 07:30:40.536 UTC [94] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id"
postgres  | 	  FROM "developers"
postgres  | 	 WHERE ("id") = ('bdb6380b-ed04-4640-b36b-a7bbe134cc91')
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.537 UTC [94] LOG:  duration: 0.210 ms
postgres  | 2023-09-19 07:30:40.538 UTC [116] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE "name" = 'default'
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.538 UTC [116] LOG:  duration: 0.266 ms
postgres  | 2023-09-19 07:30:40.538 UTC [116] LOG:  statement: SELECT "id", "name", "comment", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "meta", "config"
postgres  | 	  FROM "workspaces"
postgres  | 	 WHERE ("id") = ('afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.538 UTC [116] LOG:  duration: 0.076 ms
postgres  | 2023-09-19 07:30:40.540 UTC [116] LOG:  statement:   SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "consumer_id", "secret", "status", "client_addr"
postgres  | 	    FROM "consumer_reset_secrets"
postgres  | 	   WHERE ("consumer_id") = ('2b1e9c07-0aae-4980-9e8b-5a10bfbad22f')
postgres  | 	ORDER BY "id"
postgres  | 	   LIMIT 1001;
postgres  | 2023-09-19 07:30:40.540 UTC [116] LOG:  duration: 0.178 ms
postgres  | 2023-09-19 07:30:40.540 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "username", "custom_id", "type", "tags", "username_lower", "ws_id"
postgres  | 	  FROM "consumers"
postgres  | 	 WHERE ("id") = ('2b1e9c07-0aae-4980-9e8b-5a10bfbad22f')
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.540 UTC [116] LOG:  duration: 0.262 ms
postgres  | 2023-09-19 07:30:40.541 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id"
postgres  | 	  FROM "developers"
postgres  | 	 WHERE "email" = 'kongkong@konghq.com'
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.541 UTC [116] LOG:  duration: 0.193 ms
postgres  | 2023-09-19 07:30:40.542 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id"
postgres  | 	  FROM "developers"
postgres  | 	 WHERE "email" = 'kongkong@konghq.com'
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.542 UTC [116] LOG:  duration: 0.085 ms
postgres  | 2023-09-19 07:30:40.542 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "username", "custom_id", "type", "tags", "username_lower", "ws_id"
postgres  | 	  FROM "consumers"
postgres  | 	 WHERE ("id") = ('2b1e9c07-0aae-4980-9e8b-5a10bfbad22f')
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.543 UTC [116] LOG:  duration: 0.085 ms
postgres  | 2023-09-19 07:30:40.543 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id"
postgres  | 	  FROM "developers"
postgres  | 	 WHERE ("id") = ('bdb6380b-ed04-4640-b36b-a7bbe134cc91')
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.543 UTC [116] LOG:  duration: 0.083 ms
postgres  | 2023-09-19 07:30:40.544 UTC [116] LOG:  statement:    UPDATE "developers"
postgres  | 	      SET "created_at" = TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', "updated_at" = TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', "email" = 'kongkong@konghq.com', "status" = 1, "custom_id" = "custom_id", "consumer_id" = '2b1e9c07-0aae-4980-9e8b-5a10bfbad22f', "meta" = '{"full_name":"1337"}', "rbac_user_id" = "rbac_user_id", "ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0'
postgres  | 	    WHERE ("id") = ('bdb6380b-ed04-4640-b36b-a7bbe134cc91')
postgres  | 	      AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	RETURNING "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id";
postgres  | 2023-09-19 07:30:40.544 UTC [116] LOG:  duration: 0.317 ms
postgres  | 2023-09-19 07:30:40.544 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "consumer_id", "secret", "status", "client_addr"
postgres  | 	  FROM "consumer_reset_secrets"
postgres  | 	 WHERE ("id") = ('c2016744-acd0-4af3-b143-20320b634661')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.545 UTC [116] LOG:  duration: 0.085 ms
postgres  | 2023-09-19 07:30:40.545 UTC [119] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  '4141a4d3-ee30-4cbe-82b4-239b553b6049',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'developers:kongkong@konghq.com:::::afd329ce-f351-4e87-9391-9ba916d3f4b0'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.545 UTC [116] LOG:  statement:    UPDATE "consumer_reset_secrets"
postgres  | 	      SET "created_at" = TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', "updated_at" = TO_TIMESTAMP(1695108640) AT TIME ZONE 'UTC', "consumer_id" = '2b1e9c07-0aae-4980-9e8b-5a10bfbad22f', "secret" = 'x6nyTik0x9q1QOtq7KNuwByKeTPESL2g', "status" = 2, "client_addr" = '127.0.0.1'
postgres  | 	    WHERE ("id") = ('c2016744-acd0-4af3-b143-20320b634661')
postgres  | 	RETURNING "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "consumer_id", "secret", "status", "client_addr";
postgres  | 2023-09-19 07:30:40.545 UTC [116] LOG:  duration: 0.202 ms
postgres  | 2023-09-19 07:30:40.546 UTC [119] LOG:  duration: 0.749 ms
postgres  | 2023-09-19 07:30:40.546 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "path", "contents", "checksum", "ws_id"
postgres  | 	  FROM "files"
postgres  | 	 WHERE "path" = 'emails/request-access.txt'
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.546 UTC [116] LOG:  duration: 0.161 ms
postgres  | 2023-09-19 07:30:40.546 UTC [119] LOG:  statement: INSERT INTO cluster_events (
postgres  | 	  "id",
postgres  | 	  "node_id",
postgres  | 	  "at",
postgres  | 	  "nbf",
postgres  | 	  "expire_at",
postgres  | 	  "channel",
postgres  | 	  "data"
postgres  | 	) VALUES (
postgres  | 	  '07e5028b-1955-4365-8450-11a52ef98945',
postgres  | 	  '863d5a89-1bcb-4623-bd8d-fc311aa7a9df',
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC',
postgres  | 	  NULL,
postgres  | 	  CURRENT_TIMESTAMP(3) AT TIME ZONE 'UTC' + INTERVAL '3600 second',
postgres  | 	  'invalidations',
postgres  | 	  'consumer_reset_secrets:c2016744-acd0-4af3-b143-20320b634661:::::'
postgres  | 	)
postgres  | 	
postgres  | 2023-09-19 07:30:40.546 UTC [116] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "path", "contents", "checksum", "ws_id"
postgres  | 	  FROM "files"
postgres  | 	 WHERE "path" = 'emails/account-verification-pending.txt'
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.547 UTC [119] LOG:  duration: 0.361 ms
postgres  | 2023-09-19 07:30:40.547 UTC [116] LOG:  duration: 0.076 ms
postgres  | 2023-09-19 07:30:40.551 UTC [94] LOG:  statement: SELECT "id", EXTRACT(EPOCH FROM "created_at" AT TIME ZONE 'UTC') AS "created_at", EXTRACT(EPOCH FROM "updated_at" AT TIME ZONE 'UTC') AS "updated_at", "email", "status", "custom_id", "consumer_id", "meta", "rbac_user_id", "ws_id"
postgres  | 	  FROM "developers"
postgres  | 	 WHERE ("id") = ('bdb6380b-ed04-4640-b36b-a7bbe134cc91')
postgres  | 	   AND ("ws_id" = 'afd329ce-f351-4e87-9391-9ba916d3f4b0')
postgres  | 	 LIMIT 1;
postgres  | 2023-09-19 07:30:40.551 UTC [94] LOG:  duration: 0.124 ms
